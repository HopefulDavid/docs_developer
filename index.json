{
  "ai/ollama.html": {
    "href": "ai/ollama.html",
    "title": "| Vývojář",
    "summary": "Ollama Ve výchozím nastavení naslouchá na adrese: http://127.0.0.1:11434/ Important Pro naslouchání aplikace je důležité mít spuštění ollama soubor. (ollama app.exe) Změna v naslouchání adresy Proměnné prostředí ve Windows V System variables, nastavte OLLAMA_HOST s hodnotou adresy, kde má ollama naslouchat. Následně restartujte aplikaci ollama app.exe. Vypnout automatické spuštění Note Aplikace ollama je ve výchozím stavu zapnuta při spuštění počítače. Vypnout lze provést tímto způsobem: Windows + R, následně napsat: shell:startup -> odkliknout OK Odstranit zástupce na Ollama. Příkazy Nainstalované moduly ollama list Stažení modelu ollama run [model] Odstranění modelu ollama rm [model]"
  },
  "database/Dapper.html": {
    "href": "database/Dapper.html",
    "title": "| Vývojář",
    "summary": "Dapper Kdy použít Note Pro projekty, kde je klíčový výkon nebo kontrola nad databází. Výkon: Maximální výkon, nízká režie Snadnost vývoje: Ruční psaní SQL, více práce Komplexní modely: Ruční správa modelů Flexibilita dotazů: Vysoká – plná kontrola nad SQL Použití Instalace NuGet balíčku: dotnet add package Dapper Konfigurace a použití: using System; using System.Data.SqlClient; using System.Threading.Tasks; using Dapper; // Příklad implementace v aplikační vrstvě public class UserRepository { private readonly string _connectionString; public UserRepository(string connectionString) { _connectionString = connectionString; } // Metoda na získání uživatelů starších než zadaný věk public async Task<IEnumerable<User>> GetUsersOlderThanAsync(int age) { const string sql = \"SELECT Id, Name, Age FROM Users WHERE Age > @Age\"; using (var connection = new SqlConnection(_connectionString)) { return await connection.QueryAsync<User>(sql, new { Age = age }); } } } // Model entity public class User { public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } } // Použití repository ve službě public class UserService { private readonly UserRepository _repository; public UserService(UserRepository repository) { _repository = repository; } public async Task ShowUsersAsync() { var users = await _repository.GetUsersOlderThanAsync(18); foreach (var user in users) { Console.WriteLine($\"ID: {user.Id}, Name: {user.Name}, Age: {user.Age}\"); } } } // Hlavní program class Program { static async Task Main() { var connectionString = \"Server=myServer;Database=myDatabase;User Id=myUser;Password=myPassword;\"; var userRepository = new UserRepository(connectionString); var userService = new UserService(userRepository); await userService.ShowUsersAsync(); } } Note Dapper je v tomo příkladu použit v následující části kódu: using (var connection = new SqlConnection(_connectionString)) { return await connection.QueryAsync<User>(sql, new { Age = age }); }"
  },
  "database/EntityFramework.html": {
    "href": "database/EntityFramework.html",
    "title": "| Vývojář",
    "summary": "Entity Framework Kdy použít Note Pro rychlý vývoj aplikací s menšími nároky na výkon a větší komplexitou modelů. Výkon: Nižší výkon kvůli režii ORM (Object Relation Mapping) Snadnost vývoje: Rychlý vývoj s minimálním SQL Komplexní modely: Automatická správa modelů a migrací Flexibilita dotazů: Omezenější – závisí na EF generátoru Instalace \"C:\\Program Files\\dotnet\\dotnet.exe\" tool install --ignore-failed-sources --global dotnet-ef Note Balíček bude uložen ve složce: C:\\Users\\<TvéUživatelskéJméno>\\.dotnet\\tools Pro zálohu offline, zkopírujte obsah této složky na jiný počítač, kde nástroj dotnet-ef nebude dostupný online. Warning Pokud složku umístíte na jinou cestu, ujistěte se, že ji přidáte do proměnných do PATH, aby byl nástroj dostupný z příkazového řádku. 1. Spusťte build pro zobrazení chyb dotnet build 2. Vytvořte první migraci Important Ujistěte se, že se nacházíte ve složce, kde se nachází váš .csproj soubor dotnet ef migrations add InitialCreate 3. Aktualizujte databázi pomocí migrace dotnet ef database update Použití Instalace NuGet balíčku: dotnet add package Microsoft.EntityFrameworkCore dotnet add package Microsoft.EntityFrameworkCore.SqlServer Konfigurace a použití: using System; using System.Linq; using System.Threading.Tasks; using Microsoft.EntityFrameworkCore; // Model entity public class User { public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } } // DbContext pro správu databáze public class AppDbContext : DbContext { public DbSet<User> Users { get; set; } protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.UseSqlServer(\"Server=myServer;Database=myDatabase;User Id=myUser;Password=myPassword;\"); } } // Služba pro práci s uživateli public class UserService { private readonly AppDbContext _dbContext; public UserService(AppDbContext dbContext) { _dbContext = dbContext; } public async Task ShowUsersAsync() { var users = await _dbContext.Users .Where(u => u.Age > 18) .ToListAsync(); foreach (var user in users) { Console.WriteLine($\"ID: {user.Id}, Name: {user.Name}, Age: {user.Age}\"); } } } // Hlavní program class Program { static async Task Main() { using var dbContext = new AppDbContext(); var userService = new UserService(dbContext); await userService.ShowUsersAsync(); } } Příkazy Příkaz Popis dotnet ef migrations add <Název> Vytvoří nový soubor pro migraci s názvem <Název>, který zachytí změny ve tvých modelech (entitách). dotnet ef migrations remove Smaže poslední migraci, kterou jsi přidal, ale nezmění databázi (pouze vrátí kód zpět). dotnet ef migrations list Zobrazí seznam všech migrací, které jsi vytvořil (ukazuje, jaké změny se postupně prováděly). dotnet ef database update Aplikuje všechny migrace (změny) na databázi, aby se databáze aktualizovala podle aktuálních modelů. dotnet ef database update <Název> Aplikuje migraci s názvem <Název> (pokud nechceš aplikovat všechny migrace). dotnet ef database drop Smaže celou databázi – dávej pozor, tímto příkazem přijdeš o všechna data. dotnet ef dbcontext list Ukáže všechny třídy DbContext ve tvém projektu (DbContext je hlavní třída pro práci s databází). dotnet ef dbcontext info Zobrazí informace o tvojí DbContext třídě (užitečné pro zjištění detailů o konfiguraci). dotnet ef dbcontext scaffold Vytvoří třídy (modely) podle existující databáze – tímto způsobem můžeš začít, pokud už máš databázi. dotnet ef migrations script Vygeneruje SQL skript, který obsahuje všechny změny v migracích – vhodné pro manuální nasazení."
  },
  "database/MSSQL.html": {
    "href": "database/MSSQL.html",
    "title": "| Vývojář",
    "summary": "Microsof SQL Kód Získat informace Informace ze Serveru SELECT SERVERPROPERTY('MachineName') AS MachineName, SERVERPROPERTY('ServerName') AS ServerName, SERVERPROPERTY('InstanceName') AS InstanceName, SERVERPROPERTY('IsClustered') AS IsClustered, SERVERPROPERTY('Edition') AS Edition, SERVERPROPERTY('ProductVersion') AS ProductVersion, SERVERPROPERTY('ProductLevel') AS ProductLevel, SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS PhysicalMachineName, CONNECTIONPROPERTY('client_net_address') AS ClientIPAddress Informace z Tabulky DECLARE @tableName NVARCHAR(128) = N'place_table_name'; SELECT C.TABLE_SCHEMA as 'Namespace', C.TABLE_NAME as 'Název tabulky', C.COLUMN_NAME as 'Název sloupce', C.DATA_TYPE as 'Typ dat', C.IS_NULLABLE as 'Může být NULL ?', T.TABLE_TYPE as 'Typ tabulky' FROM INFORMATION_SCHEMA.COLUMNS C INNER JOIN INFORMATION_SCHEMA.TABLES T ON C.TABLE_NAME = T.TABLE_NAME AND C.TABLE_SCHEMA = T.TABLE_SCHEMA WHERE C.TABLE_NAME = @tableName ORDER BY C.ORDINAL_POSITION; Velikost Tabulek SELECT t.NAME AS [Název tabulky], s.Name AS [Název schématu], p.rows AS [Počet řádků], CONVERT(NVARCHAR, CAST(SUM(a.total_pages) * 8 / 1024.0 / 1024.0 AS DECIMAL(10, 2))) + ' GB (' + CONVERT(NVARCHAR, CAST((SUM(a.total_pages) * 8 / 1024.0) AS INT)) + ' MB)' AS [Celkový prostor], CONVERT(NVARCHAR, CAST(SUM(a.used_pages) * 8 / 1024.0 / 1024.0 AS DECIMAL(10, 2))) + ' GB (' + CONVERT(NVARCHAR, CAST((SUM(a.used_pages) * 8 / 1024.0) AS INT)) + ' MB)' AS [Využitý prostor], CONVERT(NVARCHAR, CAST((SUM(a.total_pages) - SUM(a.used_pages)) * 8 / 1024.0 / 1024.0 AS DECIMAL(10, 2))) + ' GB (' + CONVERT(NVARCHAR, CAST(((SUM(a.total_pages) - SUM(a.used_pages)) * 8 / 1024.0) AS INT)) + ' MB)' AS [Nevyužitý prostor] FROM sys.tables t INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id LEFT OUTER JOIN sys.schemas s ON t.schema_id = s.schema_id WHERE t.NAME NOT LIKE 'dt%' AND t.is_ms_shipped = 0 AND i.OBJECT_ID > 255 GROUP BY t.Name, s.Name, p.Rows ORDER BY SUM(a.total_pages) * 8 / 1024.0 / 1024.0 DESC; Note Zaokrouhle na dvě místa Informace o indexech na sloupcích Tip Indexy jsou nejefektivnější, když jsou často čteny a málo aktualizovány SELECT OBJECT_NAME(s.object_id) AS 'Table', i.name AS 'Index', user_seeks + user_scans + user_lookups AS 'Reads', user_updates AS 'Updates' FROM sys.dm_db_index_usage_stats AS s JOIN sys.indexes AS i ON s.object_id = i.object_id AND i.index_id = s.index_id WHERE OBJECTPROPERTY(s.object_id,'IsUserTable') = 1 ORDER BY 'Reads' DESC, 'Updates' ASC Hledat Sloupec a zjistit v jaké Tabulce se nachází Komplexní informace (včetně názvu schématu) SELECT t.name AS table_name, SCHEMA_NAME(schema_id) AS schema_name, c.name AS column_name FROM sys.tables AS t INNER JOIN sys.columns c ON t.OBJECT_ID = c.OBJECT_ID WHERE c.name LIKE '%ino_doklad%' ORDER BY schema_name, table_name; Základní informace (pouze názvy tabulek a sloupců) SELECT TABLE_NAME, COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME LIKE '%place_column_name%' Datový typ Sloupce z Tabulky Vyhledat datový typ sloupce: SELECT DATA_TYPE FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'place_table_name' AND COLUMN_NAME = 'place_column_name' Hodnoty ve všech textových a číselných sloupcích databáze Prohledává textové i číselné hodnoty napříč všemi tabulkami a sloupci vybrané databáze. Pokud zadáte číslo, použije přesné porovnání, a pokud zadáte text, použije vyhledávání pomocí LIKE DECLARE @SearchStr nvarchar(100) = 'Doplňte hledanou hodnotu zde!' CREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630)) SET NOCOUNT ON DECLARE @TableName nvarchar(256), @ColumnName nvarchar(128), @SearchStr2 nvarchar(110) SET @TableName = '' -- Rozhodnutí, zda hledaný řetězec je číslo nebo text (pro dynamické SQL) IF ISNUMERIC(@SearchStr) = 1 SET @SearchStr2 = @SearchStr ELSE SET @SearchStr2 = QUOTENAME('%' + @SearchStr + '%','''') -- Získání celkového počtu tabulek DECLARE @TotalTables int, @CompletedTables int SELECT @TotalTables = COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' SET @CompletedTables = 0 WHILE @TableName IS NOT NULL BEGIN SET @ColumnName = '' SET @TableName = ( SELECT MIN(QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME)) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) > @TableName AND OBJECTPROPERTY( OBJECT_ID( QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) ), 'IsMSShipped' ) = 0 ) WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) BEGIN SET @ColumnName = ( SELECT MIN(QUOTENAME(COLUMN_NAME)) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) AND TABLE_NAME = PARSENAME(@TableName, 1) -- Rozšíření pro textové i číselné datové typy AND DATA_TYPE IN ('char', 'varchar', 'nchar', 'nvarchar', 'int', 'decimal', 'float', 'numeric', 'bigint', 'smallint') AND QUOTENAME(COLUMN_NAME) > @ColumnName ) IF @ColumnName IS NOT NULL BEGIN -- Dynamický SQL pro číselné a textové typy IF ISNUMERIC(@SearchStr) = 1 BEGIN INSERT INTO #Results EXEC ( 'SELECT ''' + @TableName + '.' + @ColumnName + ''', CAST(' + @ColumnName + ' AS nvarchar(3630)) FROM ' + @TableName + ' (NOLOCK) ' + ' WHERE ' + @ColumnName + ' = ' + @SearchStr2 ) END ELSE BEGIN INSERT INTO #Results EXEC ( 'SELECT ''' + @TableName + '.' + @ColumnName + ''', LEFT(' + @ColumnName + ', 3630) FROM ' + @TableName + ' (NOLOCK) ' + ' WHERE ' + @ColumnName + ' LIKE ' + @SearchStr2 ) END END END -- Aktualizace počtu dokončených tabulek a výpis pokroku SET @CompletedTables = @CompletedTables + 1 PRINT 'Dokončeno ' + CAST(@CompletedTables AS nvarchar) + ' z ' + CAST(@TotalTables AS nvarchar) + ' tabulek.' END SELECT ColumnName, ColumnValue FROM #Results DROP TABLE #Results Nejnovější a Nejstarší záznam SELECT MIN(date_column) as Oldest, MAX(date_column) as Newest FROM table_name; Nejčastěji se vyskytující hodnoty SELECT place_column_name, COUNT(*) FROM place_table_name GROUP BY place_column_name ORDER BY COUNT(*) DESC; Port na kterém je spuštěn Server EXEC xp_readerrorlog 0, 1, N'Server is listening on'; Výkon Efektivita dotazů SQL Server Managment Studio V menu SSMS vyberte Query > Include Client Statistics. Spusťte svůj dotaz. JetBrains File -> Settings -> Database -> General Zaškrtnout: Show query statistics. SET STATISTICS TIME ON; SELECT * FROM place_table -- custom code to execute SET STATISTICS TIME OFF; Konfigurace Vzdálený přístup EXEC sp_configure 'remote access'; Note run_value = 1 znamená, že vzdálený přístup je povolen. Pokud je hodnota 0, povolte vzdálený přístup příkazem: EXEC sp_configure 'remote access', 1; RECONFIGURE; Spojování Spojování Tabulek left join Vrátí všechny řádky z první tabulky. Note Pokud existuje odpovídající řádek v druhé tabulce, budou vráceny hodnoty z obou tabulek. Pokud neexistuje odpovídající řádek v druhé tabulce, budou hodnoty z druhé tabulky NULL. SELECT employees.name AS EmployeeName, departments.name AS DepartmentName FROM employees LEFT JOIN departments ON employees.department_id = departments.id; Tento dotaz vrátí všechny zaměstnance a odpovídající oddělení (pokud existuje a pokud ne, bude hodnota DepartmentName NULL). right join Vrátí všechny řádky z druhé tabulky Note Pokud existuje odpovídající řádek v první tabulce, budou vráceny hodnoty z obou tabulek. Pokud neexistuje odpovídající řádek v první tabulce, budou hodnoty z první tabulky NULL. SELECT employees.name AS EmployeeName, departments.name AS DepartmentName FROM employees RIGHT JOIN departments ON employees.department_id = departments.id; Tento dotaz vrátí všechny oddělení a odpovídající zaměstnance (pokud existuje a pokud ne, bude hodnota EmployeeName NULL). full outter join Vrátí všechny řádky z obou tabulek. Note Pokud dojde k shodě, budou vráceny hodnoty z obou tabulek. Pokud nedojde k shodě, řádek nebude vrácen. SELECT employees.name AS EmployeeName, departments.name AS DepartmentName FROM employees FULL OUTER JOIN departments ON employees.department_id = departments.id; Příkaz vrátí všechny zaměstnance a oddělení (pokud existují a pokud ne, budou hodnoty NULL). inner join Vrátí pouze řádky, které mají odpovídající hodnoty v obou tabulkách. Note Pokud dojde k shodě, budou vráceny hodnoty z obou tabulek. Pokud nedojde k shodě, řádek nebude vrácen. SELECT employees.name [Employee Name], departments.name [Department Name] FROM employees INNER JOIN departments ON employees.department_id = departments.id; Tento dotaz vrátí pouze zaměstnance, kteří mají odpovídající oddělení. cross apply Je užitečný, když potřebujete provést poddotaz pro každý řádek z první tabulky, což nelze snadno dosáhnout pomocí INNER JOIN. SELECT t1.column1, t2.column2 FROM table1 t1 CROSS APPLY ( SELECT column2 FROM table2 WHERE t1.column1 = table2.column2 ) t2; Tento dotaz vrátí všechny řádky z table1 a pro každý řádek provede poddotaz, který vrátí odpovídající hodnotu z table2. Spojování Hodnot ze sloupce do řetězce SELECT STRING_AGG(column_name, ';') AS concatenated_values FROM table_name GROUP BY grouping_column Spojí hodnoty ze sloupce column_name do jednoho řetězce odděleného středníkem ; a seskupí je podle grouping_column. Note Příklad: Mějme tabulku zamestnanci: jmeno | oddeleni ----------|---------- Jan | IT Petr | IT Marie | HR Eva | HR Pavel | IT Po spuštění dotazu: SELECT oddeleni, STRING_AGG(jmeno, ';') AS seznam FROM zamestnanci GROUP BY oddeleni Dostaneme výsledek: oddeleni | seznam ----------|--------------- IT | Jan;Petr;Pavel HR | Marie;Eva"
  },
  "database/PostgreSQL.html": {
    "href": "database/PostgreSQL.html",
    "title": "| Vývojář",
    "summary": "PostgreSQL Podporuje programovací jazyky: C, C++, Java, Perl, Python, Ruby, Tcl, Scheme, PHP, Swift, Go, JavaScript, TypeScript, R, Rust, Kotlin, Lua, Erlang, Elixir, Haskell, Scala, D, Julia, PL/pgSQL, SQL, PL/Python, PL/Perl, PL/Tcl, PL/Java, PL/R, PL/V8 Note PL znamená \"Procedural Language\" (procedurální jazyk) Tyto jazyky se používají k psaní funkcí a spouštěcích procedur v rámci databáze PostgreSQL. Procedurální jazyky umožňují provádět složitější logiku a operace přímo v databázi. PostgreSQL podporuje v podstatě všechny funkce, které podporují jiné systémy pro správu databází. Uživatelské rozhraní Otevřete aplikaci: Instalace Výběr verze produktu Spustit instalaci Po dokončení stahování dvakrát klikněte na stažený soubor a spusťte instalaci: Složka pro instalaci Můžete zadat umístění PostgreSQL, vybereme prozatím výchozí volbu: Výběr komponent Note Chcete-li používat PostgreSQL, budete muset nainstalovat PostgreSQL Server. Doporučuji pgAdmin 4, který poskytuje uživatelské rozhraní a Comand Line Tools pro příkazový řádek. Složka pro uložení dat databáze Vyberte kam uložit data databáze, použijeme výchozí volbu: Nastavit heslo Pro přístup do databáze budete muset zvolit heslo. Port k naslouchání Můžete nastavit port, na kterém má server naslouchat, použijeme výchozí volbu: Geografické umístění serveru Vyberte geografické umístění databázového serveru: Kontrola před provedením Následně stačí dokončit instalaci Příkazový řádek Otestovat zda PostgreSQL naslouchá Otevřít: Připojení: Nyní byste měli dostat výsledek podobný níže: Warning Pokud nevidíte konzoli v angličtině, musíte udělat tyto změny: Nastavit v C:\\Program Files\\PostgreSQL\\16\\data\\postgresql.conf > > Nastavit v proměnném prostředí > > Nyní stačí vypnout a zapnout konzoli a změny by se měli projevit Pro odzkoušení zda jsme se správně připojili stačí zavolat kód níže: SELECT version();"
  },
  "database/mongoDB.html": {
    "href": "database/mongoDB.html",
    "title": "| Vývojář",
    "summary": "Co je MongoDB = Dokumentová databáze NoSQL (typ databáze) Note Nevyužívá tabulkový formát, který je běžný u SQL databází. Data ukládá ve formátu zvaném BSON. (Binární verze formátu JSON) Tip Formát BSON podporuje více datových typů. Efektivnější při encoding a decoding než JSON. Klíčové pojmy Dokumenty Záznamy v MongoDB. Note Každý dokument je struktura dat podobná JSON. Kolekce Data jsou organizována do kolekce Note Jsou to ekvivalenty tabulek v SQL. Každá kolekce obsahuje dokumenty, což jsou jednotlivé záznamy dat. Note Na rozdíl od řádků v tabulce SQL nemusí mít dokumenty v MongoDB stejnou strukturu. To znamená, že různé dokumenty ve stejné kolekci mohou mít různé sady polí. Příklad: var document1 = { name: \"Peter\", age: 30, residence: \"Prague\" }; db.myPeople.insert(document1); var document2 = { name: \"Anna\", age: 25, occupation: \"Engineer\" }; db.myPeople.insert(document2); BSON Formát ve kterém jsou data uložena. Note Je to binární verze JSON. Kód Vytvořit Databázi use mydb Kolekci mydb.createCollection('mycollection') Vložit dokument do kolekce mydb.mycollection.insert({name: 'test'}) Vložit více dokumentů do kolekce mydb.mycollection.insertMany([{name: 'test1'}, {name: 'test2'}]) Vytvořit index mydb.mycollection.createIndex({name: 1}) Tip Index je vytvořen na pole name Vzestupný = 1 Sestupný = -1 Vzestupné a sestupné indexy určují pořadí, ve kterém jsou data v indexu uložena, což může ovlivnit výkon a rychlost dotazů, které vyžadují řazení Vytvoření více indexů mydb.mycollection.createIndexes([{ key: { name: 1 } }, { key: { age: -1 } }]) Hledat Výpis databází show dbs Výpis dokumentů mydb.mycollection.find() Výpis kolekcí show collections Hledání dokumentu mydb.mycollection.find({name: 'test'}) Hledání dokumentu s určitými poli mydb.mycollection.find({name: 'test'}, {name: 1}) Hledání dokumentu s regulárním výrazem mydb.mycollection.find({name: {$regex: 'te.*'}}) Aktualizovat Aktualizace dokumentu mydb.mycollection.update({name: 'test'}, {$set: {name: 'newTest'}}) Aktualizace více dokumentů mydb.mycollection.updateMany({}, {$set: {name: 'newTest'}}) Aktualizace dokumentu s upsert mydb.mycollection.update({name: 'test'}, {$set: {name: 'newTest'}}, {upsert: true}) Note \"upsert\" je kombinací \"update\" a \"insert\" Aktualizuje existující dokument, nebo pokud dokument neexistuje, vloží nový dokument. Smazat Smazání databáze db.dropDatabase() Smazání kolekce mydb.mycollection.drop() Smazání dokumentu mydb.mycollection.remove({name: 'test'}) Smazání všech dokumentů mydb.mycollection.remove({}) Počet Počet dokumentů v kolekci mydb.mycollection.count() Počet dokumentů odpovídajících určitému dotazu mydb.mycollection.count({name: 'test'}) Počet unikátních hodnot v určitém poli mydb.mycollection.distinct('name').length Počet dokumentů odpovídajících regulárnímu výrazu mydb.mycollection.count({name: {$regex: 'te.*'}}) Setřídit Seřazení dokumentů podle pole mydb.mycollection.find().sort({name: 1}) Seřazení dokumentů podle více políí mydb.mycollection.find().sort({name: 1, age: -1}) Seřazení a omezení počtu dokumentů mydb.mycollection.find().sort({name: 1}).limit(5) Seřazení a přeskočení dokumentů mydb.mycollection.find().sort({name: 1}).skip(5) Rady a Tipy Povolení autorizace MongoDB má vestavěný systém pro správu uživatelů a rolí. Pro povolení autorizace upravte konfigurační soubor MongoDB a nastavte security.authorization na enabled. security: authorization: \"enabled\" Využití indexů Indexy v MongoDB vytváříte pomocí metody createIndex(). Například pro vytvoření vzestupného indexu na pole name v kolekci mycollection použijete následující příkaz: db.mycollection.createIndex({name: 1}) Optimalizace dotazů MongoDB poskytuje operátor explain(), který vám umožní zjistit, jak databáze vykonává váš dotaz. Tímto způsobem můžete identifikovat, které části dotazu je třeba optimalizovat. db.mycollection.find({name: 'test'}).explain() Správné modelování dat MongoDB je dokumentová databáze, která umožňuje velmi flexibilní modelování dat. Při návrhu vašeho datového modelu zvažte, jak budou data dotazována a jaké budou pracovní zátěže. Škálování MongoDB podporuje horizontální škálování pomocí replikačních sad a sharding. Pro větší aplikace zvažte použití těchto funkcí pro zlepšení výkonu a dostupnosti. Paměť MongoDB využívá paměť pro ukládání pracovní sady, což zlepšuje výkon dotazů. Ujistěte se, že váš server má dostatek RAM pro vaše pracovní zátěže. Šetření prostředky Pokud máte dotazy, které se často opakují, zvažte ukládání výsledků těchto dotazů pro pozdější použití. To může šetřit výpočetní prostředky a zlepšit výkon vaší aplikace."
  },
  "documentation/doxygen.html": {
    "href": "documentation/doxygen.html",
    "title": "| Vývojář",
    "summary": "Doxygen Slouží k automatickému generování dokumentace z komentářů v kódu. Je to velmi užitečný nástroj pro vývojáře, kteří chtějí mít přehlednou a strukturovanou dokumentaci ke kódu. Instalace \uD83D\uDD39 Krok 1: Instalace potřebných nástrojů Nainstalovat Doxygen Stáhněte a nainstalujte z doxygen.nl. Po instalaci ověřte, že funguje, spuštěním příkazu v terminálu nebo příkazovém řádku: doxygen --version Nainstalujte Graphviz (pro generování diagramů) Stáhněte z Graphviz Download a nainstalujte. Přidejte cestu ke složce Graphviz/bin do systémové PATH, aby Doxygen našel dot.exe. Ověřte, že Graphviz funguje: dot -version Nainstaluj TeX Live nebo MiKTeX (pro PDF) Windows: Stáhněte si MiKTeX miktex.org/download Linux: sudo apt install texlive-full Mac: brew install mactex \uD83D\uDD39 Krok 2: Vytvoření konfiguračního souboru Doxygen Otevřete terminál / CMD v adresáři projektu a vytvořte Doxyfile: doxygen -g Doxyfile Tím se vytvoří soubor Doxyfile, který bude obsahovat všechna nastavení. Otevřete Doxyfile v textovém editoru a upravte klíčové parametry: INPUT = ../../ PROJECT_NAME = \"Moje C# dokumentace\" OUTPUT_DIRECTORY = \"docs\" RECURSIVE = YES EXTRACT_ALL = YES GENERATE_LATEX = YES GENERATE_HTML = NO GENERATE_XML = NO HAVE_DOT = YES UML_LOOK = YES DOT_PATH = \"C:/Program Files/Graphviz/bin\" SHOW_USED_FILES = NO SHOW_NAMESPACES = NO DOT_IMAGE_FORMAT = svg Important Tyto parametry ovlivňují generování dokumentace Obsahuje spoustu dalších nastavení, které můžeš upravit podle potřeby. \uD83D\uDD39 Krok 3: Generování dokumentace Spusťte Doxygen a vygeneruj výstupní soubory: doxygen Doxyfile Doxygen vytvoří složku s názvem docs (nebo jiným dle OUTPUT_DIRECTORY), která obsahuje vygenerovanou dokumentaci. Vynechat private a protected z dokumentace V souboru DoxyFile upravit: Along with EXTRACT_PRIVATE = NO, use the following additional settings: ENABLE_PREPROCESSING = YES MACRO_EXPANSION = YES EXPAND_ONLY_PREDEF = YES PREDEFINED = protected=private Tímto způsobem Doxygen vynechá private a protected členy z dokumentace."
  },
  "documentation/pandoc.html": {
    "href": "documentation/pandoc.html",
    "title": "| Vývojář",
    "summary": "Pandoc Pandoc je univerzální konvertor dokumentů, který dokáže převádět soubory z jednoho značkovacího formátu do jiného. Podporuje širokou škálu formátů, včetně Markdown, HTML, LaTeX a mnoha dalších. Přehled příkazů Vstupní Formát Výstupní Formát Příkaz Poznámka Užitečné Možnosti (Parametry) \uD83D\uDCDD Markdown (.md) \uD83D\uDCC4 DOCX (.docx) pandoc soubor.md -o soubor.docx Převod z Markdownu do Word dokumentu. --standalone, --template=moje-sablona.tex, --metadata title=\"Název dokumentu\" \uD83D\uDCDD Markdown (.md) \uD83C\uDF10 HTML (.html) pandoc soubor.md -o soubor.html Generování HTML souboru z Markdownu. --self-contained, --standalone, --css=style.css, --metadata title=\"Titul stránky\" \uD83D\uDCDD Markdown (.md) \uD83D\uDCD1 PDF (.pdf) pandoc soubor.md -o soubor.pdf Generování PDF souboru z Markdownu (vyžaduje LaTeX nebo jiný engine). --pdf-engine=xelatex, --template=moje-sablona.tex, --variable graphics=yes, --toc \uD83D\uDCDD Markdown (.md) \uD83D\uDCDA EPUB (.epub) pandoc soubor.md -o soubor.epub Generování e-knihy z Markdownu. --epub-metadata=metadata.xml, --css=style.css, --epub-cover-image=image.jpg, --output=output.epub \uD83D\uDCC4 DOCX (.docx) \uD83D\uDCDD Markdown (.md) pandoc soubor.docx -o soubor.md Převod Word dokumentu na Markdown. --extract-media=. (extrakce obrázků do složky media/), --standalone \uD83D\uDCC4 DOCX (.docx) \uD83C\uDF10 HTML (.html) pandoc soubor.docx -o soubor.html Generování HTML z Word dokumentu. --self-contained, --standalone, --css=style.css, --output=output.html \uD83D\uDCC4 DOCX (.docx) \uD83D\uDCD1 PDF (.pdf) pandoc soubor.docx -o soubor.pdf Generování PDF z Word souboru (vyžaduje LaTeX). --pdf-engine=xelatex, --template=moje-sablona.tex, --toc, --output=output.pdf \uD83D\uDCC4 DOCX (.docx) \uD83D\uDCDA EPUB (.epub) pandoc soubor.docx -o soubor.epub Generování e-knihy z Word souboru. --epub-metadata=metadata.xml, --css=style.css, --epub-cover-image=image.jpg \uD83C\uDF10 HTML (.html) \uD83D\uDCDD Markdown (.md) pandoc soubor.html -o soubor.md Převod HTML do Markdownu. --standalone, --self-contained, --metadata \uD83C\uDF10 HTML (.html) \uD83D\uDCC4 DOCX (.docx) pandoc soubor.html -o soubor.docx Generování Word dokumentu z HTML. --self-contained, --standalone, --extract-media=. \uD83C\uDF10 HTML (.html) \uD83D\uDCD1 PDF (.pdf) pandoc soubor.html -o soubor.pdf Generování PDF z HTML souboru (vyžaduje LaTeX nebo jiný engine). --pdf-engine=xelatex, --template=moje-sablona.tex, --toc, --output=output.pdf \uD83C\uDF10 HTML (.html) \uD83D\uDCDA EPUB (.epub) pandoc soubor.html -o soubor.epub Generování e-knihy z HTML souboru. --epub-metadata=metadata.xml, --css=style.css, --epub-cover-image=image.jpg \uD83D\uDCD1 LaTeX (.tex) \uD83D\uDCDD Markdown (.md) pandoc soubor.tex -o soubor.md Převod LaTeX souboru na Markdown. --standalone, --self-contained \uD83D\uDCD1 LaTeX (.tex) \uD83D\uDCC4 DOCX (.docx) pandoc soubor.tex -o soubor.docx Generování Word dokumentu z LaTeX souboru. --pdf-engine=xelatex, --extract-media=. \uD83D\uDCD1 LaTeX (.tex) \uD83C\uDF10 HTML (.html) pandoc soubor.tex -o soubor.html Generování HTML z LaTeX souboru. --self-contained, --standalone, --metadata \uD83D\uDCD1 LaTeX (.tex) \uD83D\uDCD1 PDF (.pdf) pandoc soubor.tex -o soubor.pdf Kompilace LaTeX souboru do PDF. --pdf-engine=xelatex, --template=moje-sablona.tex, --toc, --output=output.pdf \uD83D\uDCD1 LaTeX (.tex) \uD83D\uDCDA EPUB (.epub) pandoc soubor.tex -o soubor.epub Generování e-knihy z LaTeX souboru. --epub-metadata=metadata.xml, --css=style.css, --epub-cover-image=image.jpg \uD83D\uDCDA EPUB (.epub) \uD83D\uDCDD Markdown (.md) pandoc soubor.epub -o soubor.md Převod EPUB knihy na Markdown. --standalone, --self-contained, --metadata \uD83D\uDCDA EPUB (.epub) \uD83D\uDCC4 DOCX (.docx) pandoc soubor.epub -o soubor.docx Generování Word dokumentu z EPUB knihy. --epub-metadata=metadata.xml, --css=style.css, --extract-media=. \uD83D\uDCDA EPUB (.epub) \uD83C\uDF10 HTML (.html) pandoc soubor.epub -o soubor.html Generování HTML z EPUB knihy. --self-contained, --standalone, --metadata \uD83D\uDCDA EPUB (.epub) \uD83D\uDCD1 PDF (.pdf) pandoc soubor.epub -o soubor.pdf Generování PDF z EPUB knihy (vyžaduje LaTeX nebo jiný engine). --pdf-engine=xelatex, --template=moje-sablona.tex, --toc, --output=output.pdf \uD83D\uDCC4 RTF (.rtf) \uD83D\uDCDD Markdown (.md) pandoc soubor.rtf -o soubor.md Převod RTF do Markdownu. --standalone, --self-contained, --metadata \uD83D\uDCC4 RTF (.rtf) \uD83D\uDCC4 DOCX (.docx) pandoc soubor.rtf -o soubor.docx Generování Word dokumentu z RTF. --extract-media=. \uD83D\uDCC4 RTF (.rtf) \uD83C\uDF10 HTML (.html) pandoc soubor.rtf -o soubor.html Generování HTML z RTF souboru. --self-contained, --standalone, --metadata \uD83D\uDCC4 RTF (.rtf) \uD83D\uDCD1 PDF (.pdf) pandoc soubor.rtf -o soubor.pdf Generování PDF z RTF souboru (vyžaduje LaTeX nebo jiný engine). --pdf-engine=xelatex, --template=moje-sablona.tex, --toc, --output=output.pdf Užitečné Možnosti pro Konfiguraci Výstupů Nastavení metadat (title, author, date): pandoc soubor.md -o soubor.pdf --metadata title=\"Titul dokumentu\" --metadata author=\"Autor\" Použití vlastní šablony pro PDF/HTML: pandoc soubor.md -o soubor.pdf --template=moje-sablona.tex Generování samostatného souboru pro HTML/PDF (včetně obrázků): pandoc soubor.md -o soubor.html --standalone Přidání obrázků přímo do HTML (base64): pandoc soubor.md -o soubor.html --self-contained Vložení obrázků (s externími cestami): pandoc soubor.md -o soubor.html --extract-media=./media Zobrazení obsahu (TOC): pandoc soubor.md -o soubor.pdf --toc Výběr formátu pro PDF engine (xelatex, pdflatex, etc.): pandoc soubor.md -o soubor.pdf --pdf-engine=xelatex"
  },
  "graphics/affinity.html": {
    "href": "graphics/affinity.html",
    "title": "| Vývojář",
    "summary": "Použití mřížky (grid) View -> Show Grid (zobrazí mřížku) View -> Grid and Axis... (nastavení mřížky) Výpočet obrázku pro zarovnání na střed Note Ukázka níže používá tyto hodnoty: gridWidth = 256 px gridHeight = 256 px offsetX (posune obrázek do prava od původního) = 256 px FAQ Modrý čtverec uvnitř stránky Je způsoben odsazením. (Include margins) Řešení: Při vytváření nového dokumentu Pro otevřený dokument"
  },
  "ide/components.html": {
    "href": "ide/components.html",
    "title": "| Vývojář",
    "summary": "Komponenty Komponenty Windows Communication Foundation (WCF) Slouží pro výměnu dat mezi různými aplikacemi nebo službami: Umožňuje vytvářet komunikační kanály mezi aplikacemi, které mohou běžet na různých platformách nebo být napsané v různých jazycích. Podporuje různé komunikační protokoly, jako jsou HTTP, TCP, Named Pipes nebo MSMQ. Vhodné použití: Pro vytváření webových služeb nebo microservices. Pro scénáře, kde je potřeba podpora více protokolů a standardů (např. SOAP, REST, JSON). Windows Workflow Foundation (WF) Slouží pro automatizaci složitých procesů a pracovních postupů (workflows). Umožňuje vizuální návrh procesů pomocí diagramů (workflow) a jejich snadnou úpravu. Vhodné pro procesy zahrnující více kroků a podmínek (např. schvalování faktur, řízení procesů). Vhodné použití: Automatizace opakujících se nebo komplexních procesů. Správa pracovních postupů, kde je potřeba flexibilní modelování a snadná změna logiky."
  },
  "ide/jetBrains.html": {
    "href": "ide/jetBrains.html",
    "title": "| Vývojář",
    "summary": "Propojení s mobilním zařízením Android Important Týká se těch, co mají CPU procesor od AMD Otevřít BIOS a najít konfiguraci pro CPU (advance settings) a změnit SVM na Enabled Než začneme nastavovat Android SDK Umožňuje spravovat SDK uvnitř IDE a umožní následně i propojení s Android Studio Nastavit Android SDK Uvnitř JetBrains IDE otevřete: File -> Project Structure -> SDKs -> Project a zde nastavíte SDK pro Android Tip SDK pro android můžete stáhnout otevřením: Android Studio -> More Actions -> SDK Manager Ověřte, že máte nainstalované základní komponenty pro práci v Androidu V sekci SDK Tools by měly být nainstalovány následující komponenty: Komponenta Popis Android SDK Built-Tools Nástroje pro sestavení Android aplikací. Android SDK Command-Line Tools Příkazové nástroje pro správu Android SDK. Android Emulator Emulátor pro testování Android aplikací na různých zařízeních. Android Emulator hypervisor driver Ovladač pro zlepšení výkonu emulátoru na počítačích s Intel a AMD procesory. Android SDK Platform-Tools Nástroje pro komunikaci s Android zařízeními, jako je adb. Nastavení AVD = AVD (Android Virtual Device) je emulátor, který umožňuje spouštět aplikace na různých zařízeních Přidat do proměnné prostředí: C:\\Users\\<YourUsername>\\AppData\\Local\\Android\\Sdk\\platform-tools ADB (Android Debug Bridge) je nástroj, který umožňuje komunikaci mezi počítačem a Android zařízením Nyní zkontrolujte, zda je emulátor správně nastavený Zkontrolovat status emulátorů adb devices Restart ADB služby (v případě potřeby) adb kill-server adb start-server Propojení s mobilním zařízením Otevřít Android Studio -> More Actions -> Virtual Device Manager Vytvořit nové virtuální zařízení a spustit Vybrat zařízení v JetBrains IDE, na kterém chcete aplikaci spustit a aplikaci spustit XML komentáře Zalomení řádku Použijte: <para>&#160;</para> Warning <para></para> a <br/> nefungují pro zalomení řádku Příklad použití: /// <summary> /// This sentence shows up when the type is hovered /// <para>&#160;</para> /// <para>int PrimaryKey</para> /// <para>&#160;</para> /// <para>virtual Relation Relation</para> /// </summary> Pro více informací: XML zalomení komentáře Klávesové zkratky Parametry metody Informace o parametrech metody Ctrl + Shift + Space Procházení seznamu Vpřed Ctrl + Shift + Space Zpět Ctrl + Shift + P Regulární výrazy Použití proměnné Zkusíme naleznout proměnnou v textu, uložit ji do proměnné a následně použít k nahrazení. Čiselná proměnná Vyhledávání proměnné v textu: <h2>(.*?)</h2> Tento výraz vyhledá všechny nadpisy druhé úrovně a uloží je do proměnné. Uložení do proměnné je možné pomocí závorek () a následně se na proměnnou odkazuje pomocí $1, $2, $3 atd. Nahrazení proměnné v textu: <h2>Test $1</h2> Tento výraz nahradí nalezené nadpisy druhé úrovně za nadpis Test a proměnnou, která byla uložena v prvním výrazu. Pojmenovanná proměnná Vyhledávání proměnné v textu: <h2>(?<customName>.*?)</h2> Tento výraz vyhledá všechny nadpisy druhé úrovně a uloží je do proměnné s názvem customName. Uložení do proměnné je možné pomocí závorek (?<customName>) a následně se na proměnnou odkazuje pomocí (?<customName>). Nahrazení proměnné v textu: <h2>Test ${customName}</h2> Tento výraz nahradí nalezené nadpisy druhé úrovně za nadpis Test a proměnnou, která byla uložena v prvním výrazu."
  },
  "ide/visualStudio.html": {
    "href": "ide/visualStudio.html",
    "title": "| Vývojář",
    "summary": "Visual Studio Stažení instalátoru pro offline použití Stáhněte si instalátor Visual Studio Community z oficiálních stránek. Přesuňte se do složky, kde je uložen instalační program (např. vs_community.exe). Otevřete příkazový řádek a spusťte následující příkaz: vs_community.exe --layout C:\\visualstudio_offline --lang cs-CZ en-US --all --layout určuje složku, kam se mají stáhnout všechny potřebné soubory. --lang určuje jazyky, které se mají stáhnout. (V tomto případě se stáhnou jazyky čeština a angličtina.) --all zajistí, že se stáhnou všechny dostupné komponenty, včetně volitelných modulů a specifických nástrojů. Note Po dokončení stahování se vytvoří složka visualstudio_offline s kompletními instalačními soubory."
  },
  "index.html": {
    "href": "index.html",
    "title": "| Vývojář",
    "summary": "Změny 2025-05-19 \uD83D\uDCDA Změny v dokumentaci: aktualizace příkazů pro správu služby Winnat (docker) 2025-05-14 \uD83D\uDCDA Změny v dokumentaci: aktualizace názvů v obsahu dokumentace (docker) \uD83D\uDCDA Změny v dokumentaci: přidána nová sekce s postupem pro řešení problémů s nedostupnými porty v Dockeru. (docker) \uD83D\uDCDA Změny v dokumentaci: přidání dokumentace pro Busybox (docker) 2025-05-13 \uD83D\uDCDA Změny v dokumentaci: přidání sekcí pro zobrazení běžících kontejnerů a aktualizaci nastavení automatického spouštění kontejneru. 2025-05-10 ✨ Nové funkcionality: přidána nová dokumentace pro nastavení Duplicati a spuštění Portaineru v Dockeru. (docs) \uD83D\uDCDA Změny v dokumentaci: přidání sekce pro propojení složky z Windows s kontejnerem v dockeru 2025-05-02 \uD83D\uDCDA Změny v dokumentaci: kdy použít Pull Request a kdy použít git merge. (Git) \uD83D\uDCDA Změny v dokumentaci: postupy pro vytváření a mazání vzdálených větví v Gitu. (Git) \uD83D\uDCDA Změny v dokumentaci: přidání použití funkce STRING_AGG pro spojování hodnot ze sloupce do řetězce. (MSSQL) \uD83C\uDFA8 Změny formátování: upravení formátování SQL dotazů v dokumentaci (MSSQL) 2025-04-17 \uD83D\uDC1B Opravy chyb: opraven graf závyslostí (Clean Architecture) 2025-04-16 \uD83D\uDCDA Změny v dokumentaci: aktualizace průvodce Clean Architecture (Clean Architecture) 2025-04-14 Vyčištění změn"
  },
  "network/ssh.html": {
    "href": "network/ssh.html",
    "title": "| Vývojář",
    "summary": "SSH SSH je bezpečnější než používání uživatelského jména a hesla, protože využívá veřejný a soukromý klíč. Přípojení na GitHub Generování SSH klíče Note Pokud již máte SSH klíč, můžete tento krok přeskočit. Pokud ještě nemáte SSH klíč, budete ho muset vytvořit. To provedete pomocí následujícího příkazu v terminálu: ssh-keygen -t rsa -b 4096 -C \"<your_email@example.com>\" Tento příkaz vygeneruje nový RSA klíč s 4096 bity, který bude spojen s vaším e-mailem. Po zadání příkazu budete vyzváni k zadání umístění pro uložení klíče (obvykle se uloží do ~/.ssh/id_rsa). Následně budete vyzváni k zadání hesla pro klíč. Pokud chcete klíč chránit heslem, zadejte ho. Pokud nechcete, klíč bude uložen bez hesla. Přidání SSH klíče do GitHubu Po vytvoření klíče ho musíte přidat na GitHub. Zkopírujte veřejný SSH klíč Obsah souboru: Windows: type %userprofile%\\.ssh\\id_rsa.pub Linux/macOS: cat ~/.ssh/id_rsa.pub Přihlaste se na GitHub a přejděte do Settings > SSH and GPG keys. Klikněte na New SSH key, zadejte název klíče a vložte obsah veřejného klíče do textového pole. Poté klikněte na Add SSH key. Testování SSH připojení Po přidání SSH klíče na GitHub můžete ověřit, zda je vše správně nastaveno, pomocí následujícího příkazu: ssh -T git@github.com Pokud je vše v pořádku, uvidíte zprávu: Hi username! You've successfully authenticated, but GitHub does not provide shell access. Klónování repozitáře pomocí SSH Když máte SSH nastavené, můžete klonovat repozitáře bez zadávání hesla pomocí SSH URL. Použijte tento příkaz: git clone git@github.com:username/repository.git Tímto způsobem zajistíte, že budete používat SSH místo HTTPS pro komunikaci s GitHubem. Nastavit SSH URL pro existující repozitář Pokud jste již klonovali repozitář pomocí HTTPS URL, můžete změnit URL na SSH. Použijte tento příkaz: git remote set-url origin git@github.com:username/repository.git Tímto způsobem zajistíte, že budete používat SSH místo HTTPS pro komunikaci s GitHubem. (Tento příkaz nastaví adresu pro fetch i push.) Tip Pokud nastavíte špatně URL, můžete ji znovu nastavit pomocí tohoto příkazu. Tip Jak zjistit URL pro stahování (fetch) a nahrávání (push) v Git repozitáři: git remote -v Tento příkaz zobrazí aktuálně nastavené adresy pro fetch a push. Tip Způsob jak nastavit jednu URL pro fetch a jinou pro push Nastavit URL pro fetch: git remote set-url origin <fetch-url> Nastavit URL pro push: git remote set-url origin https://github.com/username/repo.git Zkontrolujte nastavení: git remote -v"
  },
  "network/vpn.html": {
    "href": "network/vpn.html",
    "title": "| Vývojář",
    "summary": "VPN VPN (Virtual Private Network) je technologie, která vytváří zabezpečené a šifrované připojení přes méně zabezpečenou síť, jako je internet. Funguje tak, že internetové připojení vašeho zařízení je směrováno přes soukromý server, nikoli přes poskytovatele internetových služeb (ISP = Internet Service Provider). Podrobněji jak VPN funguje: Šifrování Když se připojíte k síti VPN, zašifruje vaše data. To znamená, že veškeré informace odesílané přes internet jsou zakódované a nečitelné pro kohokoli, kdo by je mohl zachytit. Tunelování: Vaše data procházejí zabezpečeným tunelem vytvořeným sítí VPN. Tento tunel skrývá vaše data před hackery, poskytovateli internetových služeb a dalšími subjekty. Maskování IP adresy: Server VPN vám přidělí novou IP adresu, která maskuje vaši skutečnou IP adresu. To pomáhá chránit vaši identitu a polohu. Řízení přístupu: VPN vám také může umožnit přístup k obsahu omezenému na určitý region tím, že se bude zdát, že procházíte z jiného místa. Tip Příklad použití pro připojení do firemní sítě: Zabezpečení dat S VPN: Data jsou šifrována, což znamená, že jsou chráněna před neoprávněným přístupem během přenosu. To je důležité zejména při připojení přes veřejné nebo nezabezpečené sítě. Bez VPN: Data nejsou šifrována, což zvyšuje riziko jejich zachycení a zneužití třetími stranami, jako jsou hackeři nebo poskytovatelé internetových služeb. Přístup k firemním zdrojům S VPN: Umožňuje bezpečný vzdálený přístup k interním firemním zdrojům, jako jsou servery, databáze a aplikace, které jsou jinak dostupné pouze z firemní sítě. Bez VPN Přístup k těmto zdrojům je omezený nebo nemožný, pokud nejsou vystaveny veřejně, což může omezit produktivitu a schopnost pracovat na dálku. Maskování IP adresy: S VPN: VPN server přidělí novou IP adresu, což maskuje vaši skutečnou IP adresu a chrání vaši identitu a polohu. Bez VPN Vaše skutečná IP adresa je viditelná, což může vést k potenciálním bezpečnostním rizikům a sledování vaší aktivity. Tunelování: S VPN Data procházejí zabezpečeným tunelem, který skrývá vaši komunikaci před poskytovateli internetových služeb a dalšími subjekty. Bez VPN: Data procházejí přímo přes internet bez dodatečné ochrany, což zvyšuje riziko jejich zachycení a analýzy."
  },
  "network/wireshark.html": {
    "href": "network/wireshark.html",
    "title": "| Vývojář",
    "summary": "Dešifrování HTTPS (SSL/TLS) Nastavit v proměnném prostředí SSLKEYLOGFILE: Nastavte systémovou proměnnou s názvem SSLKEYLOGFILE na cestu k souboru, kam bude prohlížeč ukládat klíče. Konfigurace Wiresharku pro dešifrování SSL/TLS: Edit > Preferences > Protocols > TLS. Nastavte Pre-Master-Secret log filename na stejnou cestu, kterou jste použili pro SSLKEYLOGFILE. Zachycení a analýza paketů: Spusťte zachycení paketů ve Wiresharku. Po ukončení zachycení paketů byste měli být schopni vidět dešifrovaný provoz."
  },
  "operatingSystem/windows.html": {
    "href": "operatingSystem/windows.html",
    "title": "| Vývojář",
    "summary": "Instalace Řešení problému s neviditelným diskem při instalaci Windows Stáhněte si ovladač pro diskovou jednotku Získejte informace o diskových ovladačích: Zadejte: Shift + F10 Otevře se příkazový řádek. Zadejte: wmic diskdrive list brief Note Pokud používáte Intel RST (RAID) nebo Intel Optane, může se zobrazit Intel RAID Controller nebo Intel Optane v popisu. Intel RST (Rapid Storage Technology): Použijte \"Intel RST VMD Managed Controller\" nebo \"Intel RST VMD Controller\", pokud používáte technologii RAID nebo Intel RST. Tento ovladač bude fungovat pro většinu běžných konfigurací disků (SATA, NVMe). Intel Optane: Pokud máte v notebooku Intel Optane Memory, stáhněte ovladač **Intel Optane Memory and Storage Management **. Tento ovladač je potřebný pro správu Optane paměti a jejích disků. Ovladače by měly být ve formátu .zip. Ujistěte se, že máte rozbalený obsah souboru na USB disku (rozbalení souboru je nezbytné). Načtení ovladač během instalace Postup: Spusťte instalaci Windows. Na obrazovce, kde se výběr disků nezobrazuje nebo je omezený, klikněte na Načíst ovladač (Load Driver). Vložte USB disk, na kterém máte rozbalený ovladač. Vyberte správný ovladač. > [!IMPORTANT] > Poznat novější verzi lze za pomoci čísla verze v názvu souboru. > > Čísla jako **09AB**, **467F** atd. jsou zde jako **hexadecimální čísla** > > Například: > - Intel RST VMD Managed Controller (09AB) - 9AB je verze ovladače. > Jedná se o novější verzi než Intel RST VMD Managed Controller (08AB). > > - Intel RST VMD Controller (467F) > > Tento ovladač má nižší číselný kód (467F), což znamená, že je starší verze. Po načtení ovladače by měl být váš disk viditelný a připravený pro instalaci. Základní nastavení Zobrazení sekund v dolním panelu Klávesnicové zkratky Minimalizace/Maximalizace všech oken Win + D Skočení na adresní řádek Alt + D Chybějící klávesy na klávesnici Kontextová klávesa Řešení: Shift + F10"
  },
  "operatingSystem/windows/cmd.html": {
    "href": "operatingSystem/windows/cmd.html",
    "title": "| Vývojář",
    "summary": "Příkazový řádek Batch skript obvykle obsahuje příponu .bat nebo .cmd. SQL Spuštění všech sql skriptů ze složky for %%G in (*.sql) do sqlcmd /S serverTest /d CT46 -U userName -P password123 -i\"%%G\" pause Note for %%G Používá se k iteraci přes všechny soubory v adresáři, které odpovídají vzoru v závorce. in (*.sql) Označuje, že smyčka projde všechny soubory s příponou .sql v aktuálním adresáři. do sqlcmd Při každém průchodu smyčkou se provede příkaz sqlcmd, což je příkazový nástroj pro spouštění SQL příkazů na serveru Microsoft SQL Server. /S serverTest Tento parametr určuje název nebo IP adresu SQL serveru, ke kterému se připojuješ. (V tomto případě je to serverTest.) /d CT46 Určuje databázi, ke které se chcete připojit. (Zde je to CT46.) -U userName Určuje uživatelské jméno pro připojení k SQL serveru. (Zde je to userName.) -P password123 Určuje heslo pro uživatele userName. (Zde je to password123.) -i \"%%G\" Označuje, že soubor SQL (který je uložen v proměnné %%G – každý .sql soubor) bude použit jako vstup pro sqlcmd. Tento příkaz tedy vykoná SQL skript v daném souboru. pause, zastaví provedení skriptu a čeká na stisknutí libovolné klávesy. (To umožňuje uživateli vidět výsledky před tím, než se okno zavře.) Windows optimalizace Optimalizace disků Note Windows 10 a novější automaticky spouští TRIM na SSD discích jednou týdně. Ruční optimalizace SSD není běžně potřeba, pokud je zapnuté automatické plánování (výchozí nastavení). U HDD je doporučeno provádět defragmentaci jednou měsíčně. Tento příkaz optimalizuje disky \"C:\" a \"D:\" podle jejich typu. defrag C: D: /O \uD83D\uDD0D Rozbor příkazu: defrag – Spustí nástroj pro optimalizaci disků ve Windows. C: D: – Říká, že chceme optimalizovat disk C: (SSD) a disk D: (HDD). /O – Znamená \"Optimize\", což znamená, že Windows automaticky zjistí typ disku a použije správnou metodu optimalizace: Pokud je disk HDD → spustí defragmentaci Pokud je disk SSD → spustí TRIM \uD83D\uDD39 Co přesně se stane po spuštění? 1️⃣ SSD (C:) Nástroj zjistí, že jde o SSD a místo klasické defragmentace spustí TRIM. TRIM vymaže nepoužívané bloky a pomůže SSD efektivněji zapisovat nová data. 2️⃣ HDD (D:) Nástroj zjistí, že jde o HDD a spustí klasickou defragmentaci. Defragmentace přesune roztříštěné soubory tak, aby byly uloženy pohromadě. Výsledkem je rychlejší čtení dat a plynulejší chod disku."
  },
  "operatingSystem/windows/powerShell.html": {
    "href": "operatingSystem/windows/powerShell.html",
    "title": "PowerShell | Vývojář",
    "summary": "PowerShell Balíčky Umístění Windows: C:\\Users\\{xxx}\\Documents\\PowerShell\\Modules Změna designu Původní: Nový: Postup Tip Nainstalujte si verzi PowerShell 7.0 a vyšší. Zjištění verze: $PSVersionTable Ke stažení zde. Important Musíte mít nainstalovaný windows terminal. Ke stažení zde. Spustit PowerShell v administrátorském modu. Otevřít novou záložku. To nás vyzve do administrátorského režimu -> Yes. Zjistíme si aktuální oprávnění na uživateli. Get-ExecutionPolicy -Scope CurrentUser Nastavit oprávnění na Bypass. Set-ExecutionPolicy -Scope CurrentUser Bypass Tip Oprávnění Bypass znamená, že PowerShell spustí jakýkoliv skript bez jakýchkoliv omezení. Ověřit, že nastavení proběhlo v pořádku. Get-ExecutionPolicy -Scope CurrentUser Note Pokud znovu provedeme příkaz Get-ExecutionPolicy -Scope CurrentUser, mělo by nám to vrátit Bypass. Nyní rozdělíme okno na části. Toho docílíme skrze klávesovou zkratku Alt + Left Click. V každém oknu spustíme jednotlivé PowerShell příkazy. Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://ohmyposh.dev/install.ps1')) Install-Module posh-git Note Potvrdíme instalovat všechno skrze a. Tip Pokud chcete přepsat již nainstalované moduly, použijte parametr: -AllowClobber Nyní máme nainstalované moduly posh-git a aplikaci oh-my-posh. Změníme vzhled příkazové řádky. Warning Cesta nesmí obsahovat mezery, háčky, ani speciální znaky! oh-my-posh init pwsh --config 'C:\\Users\\{xxx}\\Themes\\PowerShell\\aliens.omp.json' | Invoke-Expression Warning Změní se projeví pouze pro aktivní okno. Note V dalších krocích si nastavíme změnu vzhledu do konfiguračního souboru, aby po každém spuštění PowerShellu se vzhled změnil. Tip Cesta k souboru se šablonami stylů ( themes): C:\\Users\\{xxx}\\themes\\aliens.omp.json aliens.omp.json = název šablony v tomto příkladu. Tip Pokud nezafunguje změna stylu konzolové řádky pro oh-my-posh Zkuste se podívat do Environment Variables a přidat cestu: C:\\Users\\user\\AppData\\Local\\Programs\\oh-my-posh\\bin. Modul si naimportujeme. Import-Module posh-git Warning Změní se projeví pouze pro aktivní okno. Note V dalších krocích si nastavíme změnu vzhledu do konfiguračního souboru, aby po každém spuštění PowerShellu se vzhled změnil. Nyní zjistíme soubor s nastavením pro PowerShell. $PROFILE Vrátí se cesta k souboru s nastavením. Toto nastavení se poté již spouští při každém spuštění PowerShell a tedy do jakéhokoli okna. Nastavíme si soubor s nastavením pro PowerShell. Pokud soubor existuje, tak otevřeme v textovém editoru. Pokud soubor neexistuje, tak jej vytvoříme. notepad $PROFILE Potvrdíme, že chceme vytvořit nový soubor -> Yes. Do souboru s nastavením vložíme následující kód. Import-Module posh-git # Zobrazí aktuální větev a stav oh-my-posh init pwsh --config 'C:\\Users\\{xxx}\\themes\\aliens.omp.json' | Invoke-Expression # Změní vzhled příkazové řádky Uložíme a zavřeme soubor. Nastavíme oprávnění na spouštění pouze vlastních skriptů. Set-ExecutionPolicy -Scope CurrentUser RemoteSigned Tip Nastavit oprávnění na RemoteSigned, aby se neoprávněné osoby nemohly pokoušet spouštět virové skripty na Vašem zařízení. Vypneme spuštění v administrátorském režimu. Pokud nyní otevřeme PowerShell, nebo nové okno v již stávajícím, tak by vše mělo fungovat. Nastavit theme Navigovat do složky s vzhledy (themes). Například: C:\\Users\\{xxx}\\themes\\ Nyní stačí spustit příkaz níže a zobrazí se nám všechny dostupné vzhledy. Get-PoshThemes Tip Tyto vzhledy pak lze snadno změnit v konfiguračním souboru PowerShellu. $PROFILE # Zobrazí cestu k souboru s nastavením Například změníme vzhled na catppuccino.: Import-Module posh-git # Zobrazí aktuální větev a stav oh-my-posh init pwsh --config 'C:\\Users\\{xxx}\\Documents\\themes\\catppuccin.omp.json' | Invoke-Expression # Změní vzhled příkazové řádky Šablony je možné stáhnout zde. Zdroj. Historie Umístění historie (Get-PSReadlineOption).HistorySavePath Oprávnění Zjistit oprávnění Get-ExecutionPolicy -Scope CurrentUser Zjistí jaké je nastavení pro spouštění skriptů aktuálního uživatele. Restricted = Omezené Skripty nejsou povoleny. AllSigned Podepsané skripty mohou být spuštěny pouze pokud jsou podepsány důvěryhodným vydavatelem. RemoteSigned Podepsané skripty mohou být spuštěny, ale skripty stažené z internetu musí být podepsány. Unrestricted Všechny skripty mohou být spuštěny. Undefined Není nastaveno žádné omezení. V takovém případě se pro Windows klienta použije Restricted a pro Windows server RemoteSigned. Nastavit oprávnění Nastavení oprávnění pro spouštění skriptů v PowerShellu se provádí pomocí příkazu Set-ExecutionPolicy. Příklad: Set-ExecutionPolicy -Scope CurrentUser Bypass Tip Odeberete předchozí oprávnění a nastavíte nové. AllSigned Vyžaduje, aby všechny skripty a konfigurační soubory byly podepsány důvěryhodným vydavatelem, včetně skriptů napsaných v místním počítači. Bypass Žádné omezení, všechny skripty mohou být spuštěny. Default Nastaví výchozí zásady provádění. Note Klienti windows: Restricted Servery windows: RemoteSigned RemoteSigned Vyžaduje, aby všechny skripty a konfigurační soubory stažené z Internetu byly podepsány důvěryhodným vydavatelem. Note Výchozí zásada spouštění pro počítače se serverem Windows. Restricted Nenačítá konfigurační soubory ani nespouští skripty. Note Výchozí zásady spouštění pro klientské počítače se systémem Windows. Undefined Není nastaveno žádné omezení. Warning V tomto případě je oprávnění jako pro Restricted. Unrestricted Načte všechny konfigurační soubory a spustí všechny skripty. Warning Pokud spustíte nepodepsaný skript, který byl stažen z internetu, budete před jeho spuštěním vyzváni k získání povolení. Počínaje verzí PowerShell 6.0 se jedná o výchozí zásadu spouštění pro počítače s jiným systémem než Windows, kterou nelze změnit. Více info zde. Spustit skript bez změny oprávnění powershell -ExecutionPolicy Bypass -File \"C:\\{xxx}\\Downloads\\WSL-Offline-Install.ps1\" Práce se soubory Změna metadat Změna času posledního zápisu do souboru (Get-Item \"C:\\Users\\{xxx}\\FileA.docx\").LastWriteTime = \"2024.10.10 17:00:00\" Tip Pokud chcete změnit i celkový čas v dokumentu Word, postup je následovný: Přejmenujte .docx soubor na .zip. Rozbalte soubor. V souboru docProps/app.xml najděte řádek obsahující <TotalTime> a upravte hodnotu v minutách. Zazipujte soubory zpět a změňte příponu zpět na .docx. Kopírování Ze zdroje na cílové umístění xcopy /y /z \"\\\\192.xxx.xx.xx\\files\\module.xml\" \"C:\\Users\\Test\\Downloads\\*\"` Do podsložek for /D %%G in (\"C:\\Users\\Test\\Downloads\\*\") DO (xcopy /y /z \"C:\\Users\\Test\\Downloads\\module.xml\" \"%%G\\SubDirectory\\*\") for /D Prochází podsložky %%G Proměnná pro každou podsložku Tip Nakonec přidejte příkaz pause pro zobrazení výsledků. Síť Získat název hostitele (webové adresy) Resolve-DnsName -Name <IP adresa> -Type PTR Získat síťové adaptéry (interfaces) Všechny Get-NetAdapter -physical Aktuálně aktivní Get-NetAdapter -physical | where status -eq 'up'"
  },
  "programming/appcast.html": {
    "href": "programming/appcast.html",
    "title": "| Vývojář",
    "summary": "Appcast Feed XML Appcast je RSS feed ve formátu XML. Poskytuje informace o dostupných verzích aplikace. Podporuje aktualizace aplikací pomocí technologie Sparkle. Struktura: Hlavní komponenty Element Popis <rss> Kořenový element obsahující informaci o verzi a namespace. <channel> Hlavní sekce feedu obsahující informace o kanálu aktualizací. <item> Každý jednotlivý záznam pro jednu verzi aplikace. Příklad feedu <?xml version=\"1.0\" encoding=\"utf-8\"?> <rss version=\"2.0\" xmlns:sparkle=\"http://www.andymatuschak.org/xml-namespaces/sparkle\"> <channel> <!-- Název kanálu aktualizací --> <title>Aktualizace pro MyApp</title> <!-- URL adresa feedu --> <link>https://example.com/updates.xml</link> <!-- Popis kanálu aktualizací --> <description>Aktualizace pro aplikaci MyApp</description> <!-- Datum vydání kanálu v RFC 822 formátu --> <pubDate>Thu, 18 Jan 2025 10:00:00 +0000</pubDate> <!-- Jazyk feedu (např. cs-cz, en-us) --> <language>cs-cz</language> <item> <!-- Název verze aplikace --> <title>Verze 1.0</title> <!-- URL adresa s více informacemi o verzi --> <link>https://example.com/release/1.0</link> <!-- Popis verze aplikace --> <description>První verze aplikace MyApp.</description> <!-- Datum vydání verze v RFC 822 formátu --> <pubDate>Fri, 17 Jan 2025 10:00:00 +0000</pubDate> <!-- Odkaz na instalační balíček --> <!-- url = odkaz na instalační balíček --> <!-- sparkle:version = verze aplikace --> <!-- length = velikost souboru v bajtech --> <!-- type = MIME typ souboru --> <enclosure url=\"https://example.com/files/MyApp-1.0.zip\" sparkle:version=\"1.0\" length=\"102400\" type=\"application/octet-stream\"/> </item> </channel> </rss> Hlavni komponenty: <rss> Označuje začátek feedu a specifikuje verzi RSS a použité namespace pro Sparkle. Note RSS je zkratka pro \"Rich Site Summary\" nebo \"Really Simple Syndication\". To je formát pro distribuci obsahu na webu. Atributy: Atribut Popis version Verze RSS specifikace, obvykle \"2.0\". xmlns:sparkle Namespace pro Sparkle, obvykle \"http://www.andymatuschak.org/xml-namespaces/sparkle\". Příklad: <rss version=\"2.0\" xmlns:sparkle=\"http://www.andymatuschak.org/xml-namespaces/sparkle\"> <!-- Obsah feedu viz. níže --> <channel> <item> <enclosure url=\"https://example.com/files/MyApp-1.0.zip\" sparkle:version=\"1.0\" length=\"102400\" type=\"application/octet-stream\"/> </item> </channel> </rss> <channel> Popisuje kanál feedu a obsahuje metadata, která se vztahují k celému feedu. Elementy a atributy: Element Popis Atributy <title> Název kanálu, např. „Aktualizace pro MyApp“. N/A <link> URL adresa feedu (přímý odkaz na XML soubor). N/A <description> Stručný popis kanálu. N/A <language> Jazyk feedu (např. `en-us`, `cs-cz`). N/A <copyright> Informace o autorských právech. N/A <managingEditor> Emailová adresa správce kanálu. N/A <webMaster> Emailová adresa webového správce. N/A <pubDate> Datum vydání kanálu v RFC 822 formátu. N/A <lastBuildDate> Datum poslední aktualizace kanálu. N/A <category> Kategorie kanálu. N/A <generator> Software použitý k vytvoření kanálu. N/A <docs> URL adresa specifikace RSS. N/A <cloud> Specifikace pro cloudové služby. domain: Doména služby port: Port služby path: Cesta k RPC registerProcedure: Název procedury protocol: Protokol (např. `xml-rpc`) <ttl> Čas v minutách, po který má být kanál cachován. N/A <image> Obsahuje logo nebo obrázek související s kanálem. url: URL adresa obrázku title: Titulek obrázku link: URL adresa, kam odkazuje obrázek <textInput> Formulář pro zadávání textu. title: Titulek formuláře description: Popis formuláře name: Název vstupního pole link: URL adresa, kam formulář odesílá data <skipHours> Hodiny, během kterých nemá být kanál aktualizován. hour: Hodina (0-23) <skipDays> Dny, během kterých nemá být kanál aktualizován. day: Den (např. `Monday`, `Tuesday`) Příklad: <channel> <!-- Název kanálu aktualizací --> <title>Aktualizace pro MyApp</title> <!-- URL adresa feedu --> <link>https://example.com/updates.xml</link> <!-- Popis kanálu aktualizací --> <description>Aktualizace pro aplikaci MyApp</description> <!-- Datum vydání kanálu v RFC 822 formátu --> <pubDate>Thu, 18 Jan 2025 10:00:00 +0000</pubDate> <!-- Jazyk feedu (např. cs-cz, en-us) --> <language>cs-cz</language> <!-- Informace o autorských právech --> <copyright>© 2025 MyApp</copyright> <!-- Emailová adresa správce kanálu --> <managingEditor>editor@example.com</managingEditor> <!-- Emailová adresa webového správce --> <webMaster>webmaster@example.com</webMaster> <!-- Datum poslední aktualizace kanálu --> <lastBuildDate>Thu, 18 Jan 2025 10:00:00 +0000</lastBuildDate> <!-- Kategorie kanálu --> <category>Software Updates</category> <!-- Software použitý k vytvoření kanálu --> <generator>MyApp Generator</generator> <!-- URL adresa specifikace RSS --> <docs>https://www.rssboard.org/rss-draft-1</docs> <!-- Specifikace pro cloudové služby --> <cloud domain=\"rpc.example.com\" port=\"80\" path=\"/rpc\" registerProcedure=\"myAppUpdate\" protocol=\"xml-rpc\"/> <!-- Čas v minutách, po který má být kanál cachován --> <ttl>60</ttl> <!-- Obrázek související s kanálem --> <image> <!-- URL adresa obrázku --> <url>https://example.com/logo.png</url> <!-- Titulek obrázku --> <title>MyApp Logo</title> <!-- URL adresa, kam odkazuje obrázek --> <link>https://example.com</link> </image> <!-- Formulář pro zadávání textu --> <textInput> <title>Search</title> <description>Search MyApp updates</description> <name>search</name> <link>https://example.com/search</link> </textInput> <!-- Hodiny, během kterých nemá být kanál aktualizován --> <skipHours> <hour>0</hour> <hour>1</hour> </skipHours> <!-- Dny, během kterých nemá být kanál aktualizován --> <skipDays> <day>Saturday</day> <day>Sunday</day> </skipDays> </channel> <item> Každý <item> představuje jednu verzi aplikace a její aktualizaci. Elementy a atributy: Element Popis Atributy Vnořené elementy <title> Název položky. N/A N/A <link> URL adresa položky. N/A N/A <description> Stručný popis položky. N/A N/A <author> Emailová adresa autora položky. N/A N/A <category> Kategorie, do které položka patří. N/A N/A <comments> URL adresa stránky s komentáři k položce. N/A N/A <enclosure> Popisuje mediální objekt připojený k položce. url URL adresa mediálního objektu length Velikost souboru v bajtech type MIME typ souboru sparkle:version Verze aplikace <sparkle:criticalUpdate> Označuje kritickou aktualizaci <sparkle:minimumSystemVersion> Minimální verze OS <sparkle:maximumSystemVersion> Maximální verze OS <sparkle:releaseNotesLink> Odkaz na poznámky k vydání <guid> Jedinečný identifikátor položky. N/A N/A <pubDate> Datum publikace položky. N/A N/A <source> RSS kanál, ze kterého položka pochází. N/A N/A <sparkle:tags> Sparkle-specifické tagy pro kritické aktualizace. N/A <sparkle:criticalUpdate> Označuje kritickou aktualizaci <sparkle:minimumSystemVersion> Minimální verze OS <sparkle:maximumSystemVersion> Maximální verze OS <sparkle:releaseNotesLink> Odkaz na poznámky k vydání Příklad: <item> <!-- Název položky --> <title>Verze 1.0</title> <!-- URL adresa položky --> <link>https://example.com/release/1.0</link> <!-- Stručný popis položky --> <description>První verze aplikace MyApp.</description> <!-- Emailová adresa autora položky --> <author>author@example.com</author> <!-- Kategorie, do které položka patří --> <category>Software</category> <!-- URL adresa stránky s komentáři k položce --> <comments>https://example.com/release/1.0/comments</comments> <!-- Popisuje mediální objekt připojený k položce --> <enclosure url=\"https://example.com/files/MyApp-1.0.zip\" sparkle:version=\"1.0\" length=\"102400\" type=\"application/octet-stream\"/> <!-- Jedinečný identifikátor položky --> <guid>https://example.com/release/1.0</guid> <!-- Datum publikace položky --> <pubDate>Fri, 17 Jan 2025 10:00:00 +0000</pubDate> <!-- RSS kanál, ze kterého položka pochází --> <source>https://example.com/updates.xml</source> <!-- Sparkle-specifické tagy pro kritické aktualizace --> <sparkle:tags> <sparkle:criticalUpdate/> </sparkle:tags> </item> Delta aktualizace: Warning Delta soubory je zapotřebí vytvořit pomocí nástroje pro generování delta souborů. Delta soubory obsahují pouze rozdíly mezi verzemi aplikace. Tento typ souboru šetří šířku pásma a urychluje proces aktualizace. Příklad <item> <!-- Název verze aplikace --> <title>Verze 3.0</title> <!-- Popis delta aktualizace --> <description>Delta aktualizace pro přechod z verze 2.0.</description> <!-- Datum vydání verze v RFC 822 formátu --> <pubDate>Wed, 23 Jan 2025 10:00:00 +0000</pubDate> <!-- Odkaz na instalační balíček --> <!-- url = odkaz na instalační balíček --> <!-- sparkle:version = verze aplikace --> <!-- length = velikost souboru v bajtech --> <!-- type = MIME typ souboru --> <enclosure url=\"https://example.com/files/MyApp-3.0.zip\" sparkle:version=\"3.0\" length=\"512000\" type=\"application/octet-stream\"/> <!-- Delta aktualizace --> <sparkle:deltas> <!-- Odkaz na delta soubor --> <!-- url = odkaz na delta soubor --> <!-- sparkle:version = verze aplikace --> <!-- sparkle:deltaFrom = verze, ze které se aktualizuje --> <!-- length = velikost delta souboru v bajtech --> <!-- type = MIME typ souboru --> <enclosure url=\"https://example.com/files/3.0_from_2.0.patch\" sparkle:version=\"3.0\" sparkle:deltaFrom=\"2.0\" length=\"51200\" type=\"application/octet-stream\"/> <enclosure url=\"https://example.com/files/3.0_from_2.1.patch\" sparkle:version=\"3.0\" sparkle:deltaFrom=\"2.1\" length=\"51200\" type=\"application/octet-stream\"/> <enclosure/> </sparkle:deltas> </item>"
  },
  "programming/cleanArchitecture.html": {
    "href": "programming/cleanArchitecture.html",
    "title": "Clean Architecture: Kompletní průvodce | Vývojář",
    "summary": "Clean Architecture: Kompletní průvodce \uD83D\uDC68‍\uD83D\uDCBB Úvod: Co je Clean Architecture? Clean Architecture je metodika návrhu softwaru, která klade důraz na oddělení byznys logiky od technických detailů. Veškerý kód, který se zabývá obchodními pravidly, by měl být nezávislý na technologiích jako databáze, frameworky nebo externí služby. Tato metoda podporuje: Modularitu: Kód je rozdělený do vrstev podle jeho odpovědnosti Testovatelnost: Díky oddělení logiky a implementací je snadné psát jednotkové testy Údržbu: Díky jasnému rozdělení odpovědností se aplikace lépe udržuje a rozšiřuje Základem této architektury je, že vnitřní vrstvy aplikace (byznys logika, doménové modely) nesmí záviset na vnějších vrstvách (databáze, API, UI). To znamená, že můžeš snadno změnit technologii vnější vrstvy bez ovlivnění vnitřní logiky. graph TB subgraph Externí[\"Externí systémy\"] UI[\"UI vrstva<br>(Komponenty, Stránky)\"] DB[\"Databáze\"] API[\"Externí API\"] end subgraph Aplikační[\"Aplikační vrstva\"] UseCases[\"Use Cases<br>Služby\"] DTOs[\"DTO objekty\"] end subgraph Doménová[\"Doménová vrstva (Jádro)\"] Entity[\"Entity\"] HodnotyObj[\"Hodnotové objekty\"] DomenovéSlužby[\"Doménové služby\"] Pravidla[\"Pravidla\"] end subgraph Infrastruktura[\"Infrastrukturní vrstva\"] Repozitáře[\"Repozitáře\"] ExtSlužby[\"Externí služby\"] Konfigurace[\"Konfigurace\"] end subgraph Sdílené[\"Sdílená vrstva\"] Utility[\"Utility\"] Typy[\"Typy\"] Konstanty[\"Konstanty\"] end %% Správné závislosti - směrem dovnitř k doméně UI --> UseCases UseCases --> Doménová Repozitáře ---> Doménová ExtSlužby ---> Doménová %% Implementační závislosti Repozitáře --> DB ExtSlužby --> API %% Sdílené závislosti Sdílené -.-> UI Sdílené -.-> Aplikační Sdílené -.-> Doménová Sdílené -.-> Infrastruktura %% Stylování pro light/dark mode classDef default fill:#f8f9fa,stroke:#495057,stroke-width:2px,color:#212529; classDef core fill:#198754,stroke:#495057,stroke-width:2px,color:#fff; classDef external fill:#dc3545,stroke:#495057,stroke-width:2px,color:#fff; class Doménová core; class Externí external; \uD83C\uDF10 1. Architektonické vrstvy – Přehled Vrstvy jsou základem Clean Architecture a každá vrstva má svůj specifický účel: UI Layer: Uživatelské rozhraní (UI), které zobrazuje data uživatelům a získává jejich vstupy Application Layer: Zajišťuje orchestraci akcí mezi UI a doménovou logikou, slouží pro byznys procesy Domain Layer: Obsahuje všechny obchodní logiky, entity a pravidla aplikace Infrastructure Layer: Implementace komunikace s externími systémy (databáze, API, služby třetích stran) Shared Layer: Sdílené komponenty, utility a typy, které jsou použitelné v celém projektu Struktura složek \uD83D\uDCE6 /src ├── ui/ ← Kód pro UI (React, Flutter, SwiftUI…) ├── application/ ← Orchestrace, služby, use-cases ├── domain/ ← Business logika, modely, pravidla ├── infrastructure/ ← Databáze, API, emailing, úložiště └── shared/ ← Utility, types, společné věci Směr závislostí Důležité pravidlo je, že závislosti směřují dovnitř: UI závisí na Application Application závisí na Domain Infrastructure implementuje rozhraní definované v Domain Domain nezávisí na žádné jiné vrstvě! \uD83D\uDCDA 2. Doménový návrh – Srdce aplikace Cílem doménového návrhu je oddělit byznys logiku od technické implementace. Toto oddělení usnadňuje změny v technologických detailech, aniž by to ovlivnilo samotnou logiku aplikace. ✅ Entity Entity jsou objekty s vlastní identitou a specifickým chováním v systému. Kam patří: /src/domain/entities/ Příklady souborů: Order.js, User.js, Product.js public class Order { public Order(OrderId id, List<OrderItem> items, UserId userId) { Id = id; Items = items; UserId = userId; } public OrderId Id { get; } public List<OrderItem> Items { get; } public UserId UserId { get; } public Money GetTotal() { return Items.Aggregate(Money.Zero(), (sum, item) => sum.Add(item.GetSubtotal())); } } \uD83E\uDDE9 Value objekty Value objekty jsou objekty, které jsou neměnné a nemají identitu. Jsou definovány svými hodnotami. Kam patří: /src/domain/valueObjects/ Příklady souborů: Email.js, Money.js, Address.js public class Email { private readonly string value; public Email(string value) { if (!value.Contains(\"@\")) throw new InvalidEmailException(); this.value = value; } public string GetValue() => value; } \uD83E\uDDE0 Doménové služby Doménové služby implementují logiku, která nepatří přímo do žádné entity a pracuje s více entitami. Kam patří: /src/domain/services/ Příklady souborů: ShippingCostService.js, DiscountCalculator.js public class ShippingCostService { public Money Calculate(Order order) { return order.GetTotal().GreaterThan(new Money(1000)) ? Money.Zero() : new Money(99); } } ⚖️ Policy objekty Policy objekty definují pravidla, která určují, co je možné dělat s entitami. Kam patří: /src/domain/policies/ Příklady souborů: OrderPolicy.js, AccessPolicy.js public class OrderPolicy { public static bool CanCancel(Order order, User user) { return order.BelongsTo(user) && order.Status == \"NEW\"; } } \uD83E\uDDED 3. Application Layer – Orchestrace akcí Tato vrstva je zodpovědná za orchestraci akcí mezi ostatními vrstvami. Komunikuje s doménovou logikou a zajišťuje provádění konkrétních úkolů, jako je například vytvoření objednávky. \uD83D\uDEE0 UseCase / Service UseCases definují konkrétní funkce, které aplikace nabízí. Například vytvoření objednávky. Kam patří: /src/application/useCases/ nebo /src/application/services/ Příklady souborů: PlaceOrder.js, RegisterUser.js, GenerateReport.js public interface IPlaceOrder { Task Execute(PlaceOrderInput input); } public class PlaceOrder : IPlaceOrder { private readonly IOrderRepository orderRepo; private readonly IEmailService emailService; public PlaceOrder(IOrderRepository orderRepo, IEmailService emailService) { this.orderRepo = orderRepo; this.emailService = emailService; } public async Task Execute(PlaceOrderInput input) { var order = new Order(input.UserId, input.Items); if (order.IsEmpty()) throw new EmptyCartException(); await orderRepo.Save(order); await emailService.SendConfirmation(input.UserId, order); } } \uD83D\uDCCB DTO (Data Transfer Objects) DTO objekty slouží k přenosu dat mezi vrstvami, zejména mezi Application a UI. Kam patří: /src/application/dtos/ Příklady souborů: OrderDto.js, UserProfileDto.js \uD83D\uDD0C 4. Infrastructure Layer – Implementace závislostí V této vrstvě implementujeme konkrétní technologické detaily, jako jsou připojení k databázi, emailové služby nebo API třetích stran. \uD83D\uDCE6 Repozitáře (DB) Repozitáře poskytují abstrakci nad databází a umožňují interakci s entitami. Kam patří: /src/infrastructure/repositories/ Příklady souborů: PostgresOrderRepository.js, MongoUserRepository.js public interface IOrderRepository { Task Save(Order order); Task<Order> FindById(OrderId id); } public class PostgresOrderRepository : IOrderRepository { public async Task Save(Order order) { // implementace uložení do Postgres DB } public async Task<Order> FindById(OrderId id) { // implementace načítání objednávky z Postgres DB return null; } } \uD83D\uDCE7 Služby (API, emailing, třetí strany) Externí služby, jako je odesílání emailů nebo volání API třetí strany. Kam patří: /src/infrastructure/services/ Příklady souborů: SendgridEmailService.js, StripePaymentService.js public interface IEmailService { Task SendConfirmation(string userId, Order order); } public class SendgridEmailService : IEmailService { public async Task SendConfirmation(string userId, Order order) { // Zavolání SendGrid API pro odeslání potvrzení } } ⚙️ Konfigurace Konfigurace a nastavení aplikace, včetně integrace závislostí (dependency injection). Kam patří: /src/infrastructure/config/ Příklady souborů: dependencyInjection.js, dbConfig.js \uD83C\uDFA8 5. UI Layer – Vstupy & Výstupy UI vrstva je zodpovědná pouze za interakci s uživatelem a volání příslušného use case nebo služby. Nikdy neobsahuje byznys logiku! \uD83D\uDD32 Kontrolery, Komponenty a Presentery UI vrstva zajišťuje interakci s uživatelem pro zadání objednávky. Kam patří: /src/ui/controllers/, /src/ui/components/, /src/ui/pages/ Příklady souborů: OrderController.js, ProductList.jsx, CheckoutPage.vue public class OrderController : Controller { private readonly IPlaceOrder placeOrder; public OrderController(IPlaceOrder placeOrder) { this.placeOrder = placeOrder; } public async Task<IActionResult> CreateOrder(OrderInputModel input) { await placeOrder.Execute(input); return Ok(); } } \uD83D\uDCF1 Modely a Validátory Modely pro příjem dat od uživatele a jejich validace. Kam patří: /src/ui/models/, /src/ui/validators/ Příklady souborů: OrderInputModel.js, UserFormValidator.js \uD83D\uDD04 6. Shared Layer – Sdílená funkcionalita Shared vrstva obsahuje kód, který je používán napříč celou aplikací a nepatří do jedné konkrétní vrstvy. Kam patří: /src/shared/ Příklady souborů: types.js, constants.js, utils.js, logger.js \uD83E\uDDF0 Utility a pomocné funkce Univerzální pomocné funkce používané v celém projektu. export function formatDate(date) { return new Intl.DateTimeFormat('cs-CZ').format(date); } export function generateId() { return Math.random().toString(36).substr(2, 9); } \uD83C\uDFF7️ Typy a konstanty Sdílené typy a konstanty pro celou aplikaci. export const ORDER_STATUS = { NEW: 'NEW', PENDING: 'PENDING', SHIPPED: 'SHIPPED', DELIVERED: 'DELIVERED', CANCELLED: 'CANCELLED' };"
  },
  "programming/developmentPatterns.html": {
    "href": "programming/developmentPatterns.html",
    "title": "| Vývojář",
    "summary": "Vytvořil jsem tento dokument, abych si zopakoval a zároveň si ujasnil, jaké existují vývojové vzory a k čemu slouží. dokument vývojových vzorů Note Neobsahuje všechny vývojové vzory, ale obsahuje ty nejčastěji používané."
  },
  "programming/index.html": {
    "href": "programming/index.html",
    "title": "| Vývojář",
    "summary": "Jakou platformu vybrat? Warning Informace níže jsou pouze orientační! Webové aplikace Nástroj/Framework Platformy Výhody Nevýhody React Web - Velká komunita - Znovupoužitelné komponenty - Virtuální DOM pro výkon - Bohatý ekosystém knihoven - Strmá křivka učení - Syntaxe JSX může být matoucí - Vyžaduje další knihovny pro správu stavu Vue.js Web - Snadné na naučení - Reaktivní datové vazby - Flexibilní a modulární - Silná podpora komunity - Menší ekosystém ve srovnání s React a Angular - Omezená škálovatelnost pro velké aplikace - Nedostatek podpory pro velké podniky Angular Web - Komplexní framework - Obousměrné datové vazby - Injekce závislostí - Silná podpora komunity - Strmá křivka učení - Rozsáhlý a složitý - Problémy s výkonem u velkých aplikací Svelte Web - Žádný virtuální DOM - Vysoce výkonný - Jednoduchá a stručná syntaxe - Reaktivní programovací model - Menší komunita - Omezený ekosystém - Méně vyspělý ve srovnání s jinými frameworky ASP.NET Core Web - Vysoký výkon - Cross-platformní - Silné bezpečnostní funkce - Integrace s .NET ekosystémem - Strmá křivka učení - Rozsáhlý a složitý - Omezené front-endové schopnosti Django Web - Vysoce úrovňový framework - Vestavěný administrátorský panel - Silné bezpečnostní funkce - Škálovatelný a udržovatelný - Monolitická struktura - Strmá křivka učení - Omezené front-endové schopnosti Laravel Web - Elegantní syntaxe - Vestavěná autentizace a autorizace - Silná podpora komunity - Rychlý vývoj - Problémy s výkonem - Monolitická struktura - Omezená škálovatelnost pro velké aplikace Spring Boot Web - Komplexní framework - Silné bezpečnostní funkce - Škálovatelný a udržovatelný - Integrace s Java ekosystémem - Strmá křivka učení - Rozsáhlý a složitý - Vyžaduje značnou konfiguraci Express.js Web - Minimalistický framework - Vysoký výkon - Flexibilní a modulární - Silná podpora komunity - Vyžaduje další knihovny pro plnou funkčnost - Omezené vestavěné funkce - Méně názorový, což může vést k nekonzistentnímu kódu Ruby on Rails Web - Konvence nad konfigurací - Rychlý vývoj - Vestavěný testovací framework - Silná podpora komunity - Problémy s výkonem - Monolitická struktura - Strmá křivka učení pro začátečníky Mobilní aplikace Nástroj/Framework Platformy Výhody Nevýhody React Native iOS, Android - Rychlý vývoj - Velká komunita - Znovupoužitelný kód - Podpora hot-reload - Široká podpora knihoven a pluginů - Problémy s výkonem - Velká velikost aplikace - Závislost na nativních modulech - Omezený přístup k některým nativním funkcím Flutter iOS, Android - Vysoký výkon - Krásné UI - Jeden kód pro obě platformy - Podpora hot-reload - Bohatá sada widgetů - Velká velikost aplikace - Omezené třetí strany knihovny - Strmá křivka učení pro Dart Xamarin iOS, Android - Nativní výkon - Jeden kód pro obě platformy - Silná podpora Microsoftu - Přístup k nativním API - Integrace s Visual Studio - Větší velikost aplikace - Pomalejší vývoj ve srovnání s jinými frameworky - Závislost na Microsoft ekosystému Swift iOS - Vysoký výkon - Nativní vzhled a pocit - Silná podpora Apple - Přístup k nejnovějším funkcím iOS - Omezeno na iOS - Strmá křivka učení - Menší komunita ve srovnání s multiplatformními frameworky Kotlin Multiplatform iOS, Android - Sdílení kódu mezi platformami - Silná podpora Kotlinu - Možnost postupného přechodu na multiplatformní vývoj - Stále se vyvíjí - Omezená podpora komunity - Složitější nastavení projektu Ionic iOS, Android - Webové technologie - Rychlý vývoj - Velká komunita - Široká podpora pluginů - Snadná integrace s webovými aplikacemi - Problémy s výkonem - Nevhodné pro aplikace s vysokým výkonem - Závislost na webview Cordova iOS, Android - Webové technologie - Velký ekosystém pluginů - Snadná integrace s webovými aplikacemi - Problémy s výkonem - Nevhodné pro složité aplikace - Závislost na webview NativeScript iOS, Android - Nativní výkon - Přístup k nativním API - Podpora Angular a Vue.js - Možnost psát v TypeScriptu - Menší komunita - Omezené třetí strany knihovny - Složitější ladění PhoneGap iOS, Android - Webové technologie - Snadné použití - Rychlý vývoj - Podpora Adobe - Problémy s výkonem - Nevhodné pro složité aplikace - Závislost na webview Sencha Touch iOS, Android - Bohaté UI komponenty - Dobrý výkon - Podpora MVC architektury - Integrace s Ext JS - Drahé licencování - Menší komunita - Strmá křivka učení Počítačové aplikace Nástroj/Framework Platformy Výhody Nevýhody Electron Windows, macOS, Linux - Webové technologie - Velká komunita - Široká podpora knihoven a pluginů - Snadná integrace s webovými aplikacemi - Velká velikost aplikace - Vysoká spotřeba paměti - Závislost na Chromium Qt Windows, macOS, Linux - Vysoký výkon - Bohatá sada widgetů - Podpora více jazyků (C++, Python, atd.) - Nativní vzhled a pocit - Strmá křivka učení - Drahé licencování pro komerční použití - Velikost knihovny WPF (Windows Presentation Foundation) Windows - Bohaté UI možnosti - Silná podpora Microsoftu - Integrace s .NET ekosystémem - Podpora MVVM architektury - Omezeno na Windows - Strmá křivka učení - Vyšší nároky na systémové prostředky JavaFX Windows, macOS, Linux - Podpora více platforem - Integrace s Java ekosystémem - Bohaté UI možnosti - Podpora FXML pro návrh UI - Strmá křivka učení - Menší komunita ve srovnání s jinými frameworky - Vyšší nároky na systémové prostředky GTK Windows, macOS, Linux - Nativní vzhled a pocit - Podpora více jazyků (C, Python, atd.) - Velká komunita - Otevřený zdrojový kód - Strmá křivka učení - Omezené UI možnosti ve srovnání s jinými frameworky - Složitější ladění WinForms Windows - Snadné použití - Rychlý vývoj - Integrace s .NET ekosystémem - Velká komunita - Omezeno na Windows - Zastaralý vzhled - Omezené UI možnosti ve srovnání s moderními frameworky Swing Windows, macOS, Linux - Podpora více platforem - Integrace s Java ekosystémem - Bohaté UI možnosti - Velká komunita - Zastaralý vzhled - Vyšší nároky na systémové prostředky - Strmá křivka učení Tcl/Tk Windows, macOS, Linux - Snadné použití - Rychlý vývoj - Podpora více jazyků (Tcl, Python, atd.) - Otevřený zdrojový kód - Zastaralý vzhled - Omezené UI možnosti - Menší komunita ve srovnání s jinými frameworky Databázový vývoj Nástroj/Framework Platformy Výhody Nevýhody PostgreSQL Cross-platform - Otevřený zdrojový kód - Silná podpora komunity - Pokročilé funkce - Vysoký výkon - Složitější nastavení - Vyšší nároky na systémové prostředky - Strmá křivka učení MySQL Cross-platform - Otevřený zdrojový kód - Velká komunita - Snadné použití - Vysoký výkon - Omezené pokročilé funkce - Problémy s výkonem při velkém zatížení - Méně flexibilní než PostgreSQL SQLite Cross-platform - Otevřený zdrojový kód - Snadné použití - Nízké nároky na systémové prostředky - Vestavěný v mnoha aplikacích - Omezené pokročilé funkce - Nevhodné pro velké aplikace - Omezená podpora pro víceuživatelské prostředí MongoDB Cross-platform - Otevřený zdrojový kód - Flexibilní schéma - Vysoký výkon - Silná podpora komunity - Vyšší nároky na systémové prostředky - Omezené transakční funkce - Problémy s konzistencí dat Microsoft SQL Server Windows, Linux - Silná podpora Microsoftu - Pokročilé funkce - Vysoký výkon - Integrace s .NET ekosystémem - Drahé licencování - Vyšší nároky na systémové prostředky - Omezená podpora pro jiné platformy než Windows Oracle Database Cross-platform - Pokročilé funkce - Vysoký výkon - Silná podpora pro velké podniky - Škálovatelnost - Drahé licencování - Složitější nastavení - Vyšší nároky na systémové prostředky Redis Cross-platform - Otevřený zdrojový kód - Vysoký výkon - Podpora pro různé datové struktury - Snadné použití - Omezené pokročilé funkce - Nevhodné pro trvalé ukládání dat - Omezená podpora pro složité dotazy Cassandra Cross-platform - Otevřený zdrojový kód - Vysoká škálovatelnost - Vysoký výkon - Silná podpora komunity - Složitější nastavení - Vyšší nároky na systémové prostředky - Strmá křivka učení MariaDB Cross-platform - Otevřený zdrojový kód - Velká komunita - Snadné použití - Vysoký výkon - Omezené pokročilé funkce - Problémy s výkonem při velkém zatížení - Méně flexibilní než PostgreSQL Elasticsearch Cross-platform - Otevřený zdrojový kód - Vysoký výkon - Silná podpora pro full-textové vyhledávání - Škálovatelnost - Vyšší nároky na systémové prostředky - Složitější nastavení - Omezená podpora pro transakce Herní vývoj Nástroj/Framework Platformy Výhody Nevýhody Unity Cross-platform - Velká komunita - Rozsáhlý obchod s aktivy - C# skriptování - Všestranný pro 2D a 3D hry - Strmá křivka učení - Problémy s výkonem u velkých projektů - Licenční náklady na pokročilé funkce Unreal Engine Cross-platform - Vysoce kvalitní grafika - Blueprint vizuální skriptování - Velká komunita - Zdarma pro malé projekty - Strmá křivka učení - Vysoké systémové požadavky - Licenční náklady pro projekty s vysokými příjmy Godot Cross-platform - Otevřený zdrojový kód - Lehký - GDScript pro snadné skriptování - Všestranný pro 2D a 3D hry - Menší komunita - Méně vyspělý než Unity a Unreal - Omezený obchod s aktivy GameMaker Studio Cross-platform - Snadné na naučení - Drag-and-drop rozhraní - Dobré pro 2D hry - Velká komunita - Omezené 3D schopnosti - Licenční náklady na pokročilé funkce - Problémy s výkonem u velkých projektů CryEngine Cross-platform - Vysoce kvalitní grafika - Zdarma k použití - Výkonný pro FPS hry - Velká komunita - Strmá křivka učení - Vysoké systémové požadavky - Omezená dokumentace RPG Maker Cross-platform - Snadné použití - Dobré pro RPG hry - Velká komunita - Rozsáhlý obchod s aktivy - Omezeno na RPG žánr - Omezené možnosti přizpůsobení - Licenční náklady na pokročilé funkce Construct Cross-platform - Snadné na naučení - Drag-and-drop rozhraní - Dobré pro 2D hry - Velká komunita - Omezené 3D schopnosti - Licenční náklady na pokročilé funkce - Problémy s výkonem u velkých projektů Cocos2d Cross-platform - Otevřený zdrojový kód - Dobré pro 2D hry - Lehký - Velká komunita - Omezené 3D schopnosti - Strmá křivka učení pro začátečníky - Omezený obchod s aktivy Panda3D Cross-platform - Otevřený zdrojový kód - Dobré pro 3D hry - Python skriptování - Velká komunita - Strmá křivka učení - Omezený obchod s aktivy - Méně vyspělý než Unity a Unreal Phaser Cross-platform - Otevřený zdrojový kód - Dobré pro 2D hry - JavaScript skriptování - Velká komunita - Omezené 3D schopnosti - Problémy s výkonem u velkých projektů - Omezený obchod s aktivy CI & CD Nástroj/Framework Platformy Výhody Nevýhody Jenkins Cross-platform - Otevřený zdrojový kód - Velká komunita - Široká podpora pluginů - Flexibilní a rozšiřitelný - Složitější nastavení - Vyšší nároky na systémové prostředky - Strmá křivka učení GitLab CI/CD Cross-platform - Integrované s GitLab - Snadné použití - Silná podpora komunity - Široká podpora pro různé platformy - Omezené možnosti mimo GitLab - Vyšší nároky na systémové prostředky - Složitější konfigurace pro pokročilé scénáře CircleCI Cross-platform - Snadné použití - Rychlé buildy - Silná podpora pro Docker - Integrace s GitHub a Bitbucket - Omezené možnosti pro self-hosting - Vyšší náklady pro větší týmy - Omezená podpora pro některé platformy Travis CI Cross-platform - Snadné použití - Integrace s GitHub - Podpora více jazyků - Bezplatné pro open-source projekty - Omezené možnosti pro self-hosting - Vyšší náklady pro větší týmy - Omezená podpora pro některé platformy Azure DevOps Cross-platform - Silná podpora Microsoftu - Integrace s Azure ekosystémem - Široká podpora pro různé platformy - Silné bezpečnostní funkce - Složitější nastavení - Vyšší náklady pro větší týmy - Strmá křivka učení GitHub Actions Cross-platform - Integrované s GitHub - Snadné použití - Široká podpora pro různé platformy - Silná podpora komunity - Omezené možnosti mimo GitHub - Vyšší náklady pro větší týmy - Složitější konfigurace pro pokročilé scénáře Bamboo Cross-platform - Silná podpora Atlassian - Integrace s Jira - Široká podpora pro různé platformy - Flexibilní a rozšiřitelný - Vyšší náklady pro větší týmy - Složitější nastavení - Strmá křivka učení TeamCity Cross-platform - Silná podpora JetBrains - Široká podpora pro různé platformy - Flexibilní a rozšiřitelný - Silné bezpečnostní funkce - Vyšší náklady pro větší týmy - Složitější nastavení - Strmá křivka učení Bitbucket Pipelines Cross-platform - Integrované s Bitbucket - Snadné použití - Široká podpora pro různé platformy - Silná podpora komunity - Omezené možnosti mimo Bitbucket - Vyšší náklady pro větší týmy - Složitější konfigurace pro pokročilé scénáře Spinnaker Cross-platform - Silná podpora pro multi-cloud - Flexibilní a rozšiřitelný - Silná podpora komunity - Široká podpora pro různé platformy - Složitější nastavení - Vyšší nároky na systémové prostředky - Strmá křivka učení Testování Nástroj/Framework Platformy Výhody Nevýhody Selenium Cross-platform - Otevřený zdrojový kód - Podpora více prohlížečů - Velká komunita - Flexibilní a rozšiřitelný - Složitější nastavení - Vyšší nároky na systémové prostředky - Strmá křivka učení JUnit Cross-platform - Otevřený zdrojový kód - Integrace s Java ekosystémem - Snadné použití - Velká komunita - Omezené možnosti pro ne-Java projekty - Omezené vestavěné funkce - Vyžaduje další knihovny pro plnou funkčnost TestNG Cross-platform - Otevřený zdrojový kód - Flexibilní a rozšiřitelný - Podpora paralelního testování - Integrace s Java ekosystémem - Složitější nastavení - Vyšší nároky na systémové prostředky - Strmá křivka učení Cypress Cross-platform - Snadné použití - Rychlé testování - Silná podpora pro JavaScript - Bohatá sada funkcí - Omezené možnosti pro ne-JavaScript projekty - Vyšší nároky na systémové prostředky - Omezená podpora pro některé prohlížeče Mocha Cross-platform - Snadné použití - Flexibilní a rozšiřitelný - Silná podpora pro JavaScript - Integrace s Node.js ekosystémem - Omezené vestavěné funkce - Vyžaduje další knihovny pro plnou funkčnost - Omezená podpora pro některé prohlížeče Jest Cross-platform - Snadné použití - Rychlé testování - Silná podpora pro JavaScript - Bohatá sada funkcí - Omezené možnosti pro ne-JavaScript projekty - Vyšší nároky na systémové prostředky - Omezená podpora pro některé prohlížeče PyTest Cross-platform - Otevřený zdrojový kód - Snadné použití - Silná podpora pro Python - Flexibilní a rozšiřitelný - Omezené možnosti pro ne-Python projekty - Vyšší nároky na systémové prostředky - Strmá křivka učení Robot Framework Cross-platform - Otevřený zdrojový kód - Snadné použití - Podpora více jazyků - Flexibilní a rozšiřitelný - Složitější nastavení - Vyšší nároky na systémové prostředky - Strmá křivka učení Karma Cross-platform - Snadné použití - Rychlé testování - Silná podpora pro JavaScript - Integrace s Angular ekosystémem - Omezené možnosti pro ne-JavaScript projekty - Vyšší nároky na systémové prostředky - Omezená podpora pro některé prohlížeče NUnit Cross-platform - Otevřený zdrojový kód - Integrace s .NET ekosystémem - Snadné použití - Velká komunita - Omezené možnosti pro ne-.NET projekty - Omezené vestavěné funkce - Vyžaduje další knihovny pro plnou funkčnost"
  },
  "programming/javascript.html": {
    "href": "programming/javascript.html",
    "title": "| Vývojář",
    "summary": "Balíčky Globální balíčky Umístění windows: C:\\Users<user>\\AppData\\Roaming\\npm\\node_modules npm root -g Záloha # Cesta k souboru se seznamem balíčků v aktuální pracovní složce $packageListFilePath = Join-Path -Path $PWD.Path -ChildPath 'npm_global_packages.txt' # Cesta k složce, kde se mají balíčky uložit $outputFolder = Join-Path -Path $PWD.Path -ChildPath 'offline_packages' # Záloha globálních balíčků do souboru npm_global_packages.txt Write-Host \"Zálohuji seznam globálních balíčků...\" -ForegroundColor Cyan npm list -g --depth=0 | Out-File -FilePath $packageListFilePath -Encoding utf8 # Kontrola existence souboru se seznamem balíčků if (!(Test-Path -Path $packageListFilePath)) { Write-Host \"Soubor $packageListFilePath nebyl nalezen. Zkontrolujte, zda je správně vygenerován.\" -ForegroundColor Red throw \"Soubor neexistuje.\" } # Vytvoření složky pro offline balíčky, pokud neexistuje if (!(Test-Path -Path $outputFolder)) { Write-Host \"Vytvářím složku pro offline balíčky: $outputFolder\" -ForegroundColor Yellow New-Item -ItemType Directory -Path $outputFolder | Out-Null } # Načítání obsahu souboru Write-Host \"Načítám seznam balíčků z $packageListFilePath...\" -ForegroundColor Cyan $content = Get-Content -Path $packageListFilePath # Přeskočení první řádky (pokud je soubor ve formátu, který obsahuje hlavičku) $content = $content | Select-Object -Skip 1 # Inicializace počítadel $totalPackages = 0 $successfulPackages = 0 $failedPackages = 0 # Zpracování každé řádky v souboru foreach ($line in $content) { # Odstranění přebytečných znaků na začátku řádky $line = $line.Trim() -replace '^[+`-]+\\s*', '' # Pokud je řádek prázdný nebo neobsahuje jméno balíčku, přeskočíme ho if ([string]::IsNullOrWhiteSpace($line)) { continue } # Rozdělení řádky pomocí '@' na jméno balíčku a verzi $parts = $line -split '@' $packageName = $parts[0].Trim() $version = if ($parts.Length -gt 1) { $parts[1].Trim() } else { '' } # Ověření, že balíček není součástí seznamu výjimek if ($packageName -in @(\"globalpackages.txt\", \"npm_global_packages.txt\")) { continue } # Připravit cestu k balíčku $packageDir = Join-Path -Path $outputFolder -ChildPath $packageName if (!(Test-Path -Path $packageDir)) { Write-Host \"Vytvářím složku pro balíček: $packageName\" -ForegroundColor Yellow New-Item -ItemType Directory -Path $packageDir | Out-Null } # Stáhnout balíček s verzí, pokud je specifikována $totalPackages++ $downloadSuccess = $false try { if ($version) { Write-Host \"Stahuji balíček: $packageName@$version\" -ForegroundColor Green $npmOutput = npm pack \"$packageName@$version\" --pack-destination $packageDir 2>&1 } else { Write-Host \"Stahuji balíček: $packageName\" -ForegroundColor Green $npmOutput = npm pack $packageName --pack-destination $packageDir 2>&1 } # Kontrola výstupu npm pro chyby if ($npmOutput -match \"404 Not Found\") { Write-Host \"Chyba: Balíček $packageName nebyl nalezen v npm registry.\" -ForegroundColor Red $downloadSuccess = $false } elseif ($npmOutput -match \"npm ERR\") { Write-Host \"Chyba při stahování balíčku: $packageName\" -ForegroundColor Red $downloadSuccess = $false } else { $downloadSuccess = $true } } catch { Write-Host \"Chyba při stahování balíčku: $packageName - $($_.Exception.Message)\" -ForegroundColor Red } # Pokud se stahování neprovede, zvyšujeme počet neúspěšných balíčků if ($downloadSuccess) { Write-Host \"Úspěšně staženo: $packageName\" -ForegroundColor Green $successfulPackages++ } else { Write-Host \"Neúspěšně staženo: $packageName\" -ForegroundColor Red $failedPackages++ } # Pokud balíček obsahuje package.json, stáhnout závislosti $packageJsonPath = Join-Path -Path $packageDir -ChildPath 'package.json' if (Test-Path -Path $packageJsonPath) { Write-Host \"Stahuji závislosti pro balíček: $packageName\" -ForegroundColor Cyan $dependencies = (Get-Content -Path $packageJsonPath | ConvertFrom-Json).dependencies foreach ($dependency in $dependencies.Keys) { Write-Host \"Stahuji závislost: $dependency\" -ForegroundColor Cyan try { npm pack $dependency --pack-destination $packageDir } catch { Write-Host \"Chyba při stahování závislosti ${dependency} pro balíček ${packageName}: $($_.Exception.Message)\" -ForegroundColor Red } } } } # Výpis výsledků Write-Host \"Zálohování dokončeno.\" -ForegroundColor Cyan Write-Host \"Úspěšně zálohováno: $successfulPackages z $totalPackages balíčků.\" -ForegroundColor Green Write-Host \"Neúspěšně zálohováno: $failedPackages balíčků.\" -ForegroundColor Red Obnova # Cesta k složce s offline balíčky $packageFolder = Join-Path -Path $PWD.Path -ChildPath 'offline_packages' $installBaseFolder = Join-Path -Path $PWD.Path -ChildPath 'Installed' # Kontrola, zda složka existuje if (!(Test-Path -Path $packageFolder)) { Write-Host \"Složka s offline balíčky nebyla nalezena: $packageFolder\" -ForegroundColor Red exit } # Vytvoření složky pro instalaci, pokud ještě neexistuje if (!(Test-Path -Path $installBaseFolder)) { Write-Host \"Vytvářím složku pro instalaci: $installBaseFolder\" -ForegroundColor Yellow New-Item -ItemType Directory -Path $installBaseFolder } # Získání všech .tgz souborů v dané složce a podadresářích $tgzFiles = Get-ChildItem -Path $packageFolder -Filter *.tgz -Recurse if ($tgzFiles.Count -eq 0) { Write-Host \"Nebyl nalezen žádný .tgz soubor v složce $packageFolder. Zkontrolujte, že máte offline balíčky připravené.\" -ForegroundColor Red exit } # Inicializace počítadel $totalPackages = $tgzFiles.Count $successfulPackages = 0 $failedPackages = 0 # Instalace každého .tgz souboru foreach ($tgzFile in $tgzFiles) { Write-Host \"Instaluji balíček: $($tgzFile.Name)\" -ForegroundColor Cyan # Extrahování názvu balíčku z názvu souboru .tgz $packageName = [System.IO.Path]::GetFileNameWithoutExtension($tgzFile.Name) # Vytvoření složky pro instalaci, pokud ještě neexistuje $installDir = Join-Path -Path $installBaseFolder -ChildPath $packageName if (!(Test-Path -Path $installDir)) { Write-Host \"Vytvářím složku pro instalaci: $installDir\" -ForegroundColor Yellow New-Item -ItemType Directory -Path $installDir } # Instalace balíčku pomocí .tgz souboru try { Write-Host \"Instaluji balíček z $($tgzFile.FullName)...\" -ForegroundColor Green npm install --prefix $installDir $tgzFile.FullName Write-Host \"Balíček $packageName byl úspěšně nainstalován.\" -ForegroundColor Green $successfulPackages++ } catch { Write-Host \"Chyba při instalaci balíčku $packageName z $($tgzFile.FullName): $_\" -ForegroundColor Red $failedPackages++ continue } # Pokud balíček obsahuje závislosti (package.json), pokusíme se stáhnout a nainstalovat je offline $packageJsonPath = Join-Path -Path $installDir -ChildPath \"node_modules\\$packageName\\package.json\" if (Test-Path -Path $packageJsonPath) { Write-Host \"Balíček $packageName obsahuje závislosti. Stahuji je...\" -ForegroundColor Cyan # Načteme závislosti z package.json $dependencies = (Get-Content -Path $packageJsonPath | ConvertFrom-Json).dependencies if ($dependencies) { foreach ($dependency in $dependencies.Keys) { $dependencyPackagePath = Join-Path -Path $packageFolder -ChildPath \"$dependency-*.tgz\" if (Test-Path -Path $dependencyPackagePath) { Write-Host \"Instaluji závislost: $dependency\" -ForegroundColor Cyan npm install --prefix $installDir $dependencyPackagePath } else { Write-Host \"Závislost $dependency není k dispozici pro offline instalaci!\" -ForegroundColor Red } } } } } # Výpis výsledků Write-Host \"Všechny balíčky byly úspěšně nainstalovány z offline záloh.\" -ForegroundColor Cyan Write-Host \"Úspěšně nainstalováno: $successfulPackages z $totalPackages balíčků.\" -ForegroundColor Green Write-Host \"Neúspěšně nainstalováno: $failedPackages balíčků.\" -ForegroundColor Red Aplikační balíčky conventional-changelog-cli Slouží k automatickému generování changelogu na základě commit zpráv. Instalace balíčku. npm install -g conventional-changelog-cli Generování changelogu. conventional-changelog -p angular -i CHANGELOG.md -o CHANGELOG.md -s Parameter Popis -p / --preset Přednastavený styl changelogu, např. angular, eslint, conventionalcommits. -i / --infile Vstupní soubor pro generování changelogu (např. CHANGELOG.md). -o / --outfile Výstupní soubor pro generování changelogu. -r / --release-count Počet posledních verzí, pro které bude changelog generován. --context JSON nebo JS soubor obsahující vlastní kontext pro šablonu changelogu. --pkg Cesta k package.json, může být použita pro čtení verzí a dalších údajů. --append Přidá změny na konec souboru místo přepsání celého obsahu. --same-file Přepíše stejný soubor bez použití dočasného souboru. --tag-prefix Přidá prefix k tagům verzí (např. v). -n / --config Vlastní konfigurační soubor, který přizpůsobí generování changelogu. Tip Použití vlastní šablony pro generování changelogu. conventional-changelog -i index.md -s --config ./changelog-config.js Příklad konfigurace s emoji Příklad konfigurace bez emoji"
  },
  "programming/mobile/flutter.html": {
    "href": "programming/mobile/flutter.html",
    "title": "| Vývojář",
    "summary": "Flutter Používá se pro vývoj mobilních aplikací pro Android a iOS. Využívá Dart jako programovací jazyk. Instalace a vytvoření nového projektu Instalace Important Flutter používá Git pro správu závislostí, takže je potřeba mít nainstalovaný Git. Important Flutter vyžaduje nainstalovaný Android Studio pro vývoj aplikací pro Android. Windows Stáhnout Flutter SDK z oficiálních stránek Rozbalit ZIP soubor do složky, například: C:\\src\\flutter Important Cesta nesmí obsahovat mezery nebo speciální znaky Přidat cestu k adresáři flutter\\bin do proměnného prostředí PATH Spuště nyní kontrolu zda je vše správně nastaveno: flutter doctor Příkaz pro vypnutí analyzování: flutter config --no-analytics Tip Pro kontrolu veškerého nastavení: flutter config Android toolchain - develop for Android devices Ujistěte se, že je nainstalován Android Studio Prohlížeč pro vývoj webových aplikací Pokud chcete používat jiný prohlížeč než Google Chrome: flutter config --no-web-browser Použijte flutter run -d web-server Otevřete ve vlastním prohlížeči a zadejte adresu http://localhost:PORT/ Vytvoření nového projektu flutter create project_name Nyní můžete spustit aplikaci: cd project_name flutter run Záloha/Obnova a ukládání dat Umístění aplikačních dat Aplikační data jsou uložena v následujících lokacích: shared_preferences.json: %APPDATA%\\com.example\\xxx_app Note Soubor se nachází v následující struktuře složek: %APPDATA% - složka s uživatelskými daty (C:\\Users\\<uživatel>\\AppData\\Roaming) com.example - identifikátor aplikace xxx_app - název aplikace shared_preferences.json - soubor s uloženými daty Záloha závislostí Pro zálohování všech balíčků projektu při použití flutter pub get, můžete zálohovat složku .pub-cache, která obsahuje všechny stažené závislosti. Windows: C:\\Users\\<uživatelské_jméno>\\AppData\\Local\\Pub\\Cache macOS a Linux: /Users/<uživatelské_jméno>/.pub-cache Tip Složka hosted obsahuje všechny balíčky stažené z veřejných (například: pub.dev) nebo soukromých repozitářů. (Hlavní úložiště pro závislosti projektu.) Složka hosted-hashes obsahuje hash soubory, které slouží k ověření integrity balíčků uložených ve složce hosted. (Zajišťuje, že balíčky nebyly změněny.) Složka temp obsahuje dočasné soubory, které jsou vytvořeny během stahování balíčků a jsou odstraněny po dokončení stahování. Obnova závislostí Pro obnovení všech balíčků projektu zálohovaných v .pub-cache, stačí obnovit obsah složky .pub-cache do původního umístění. Windows: C:\\Users\\<uživatelské_jméno>\\AppData\\Local\\Pub\\Cache macOS a Linux: /Users/<uživatelské_jméno>/.pub-cache Tip Složka hosted obsahuje všechny balíčky stažené z veřejných (například: pub.dev) nebo soukromých repozitářů. (Hlavní úložiště pro závislosti projektu.) Složka hosted-hashes obsahuje hash soubory, které slouží k ověření integrity balíčků uložených ve složce hosted. (Zajišťuje, že balíčky nebyly změněny.) Složka temp obsahuje dočasné soubory, které jsou vytvořeny během stahování balíčků a jsou odstraněny po dokončení stahování. Základní znalosti Widget Widget je základní stavební prvek Flutter aplikace a je zodpovědný za vykreslení uživatelského rozhraní. Každý widget je buď StatelessWidget nebo StatefulWidget. StatelessWidget - neměnný widget, který se nemění během životního cyklu aplikace class MyStatelessWidget extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Stateless Widget Example'), ), body: Center( child: Text('This is a stateless widget'), ), ); } } StatefulWidget - měnný widget, který se může měnit během životního cyklu aplikace // A StatefulWidget is a widget that has mutable state. class MyStatefulWidget extends StatefulWidget { @override _MyStatefulWidgetState createState() => _MyStatefulWidgetState(); } // This is the state class for MyStatefulWidget. // It holds the state of the widget and contains the logic to update the state. class _MyStatefulWidgetState extends State<MyStatefulWidget> { int _counter = 0; // This method increments the counter and calls setState to update the UI. void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Simple Stateful Widget Example'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text('You have pushed the button this many times:'), Text('$_counter'), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); } } void main() { runApp(MaterialApp( home: MyStatefulWidget(), )); } Příkazy Tabulka s příkazy Kategorie Příkaz Popis Verze a kanály flutter --version Zobrazí aktuální verzi Flutter SDK, Dart SDK a aktivní kanál. flutter upgrade Aktualizuje Flutter SDK na nejnovější verzi v aktuálním kanálu. flutter downgrade Vrátí Flutter SDK na předchozí verzi. flutter channel Zobrazí aktuální kanál a seznam dostupných kanálů (stable, beta, dev, master). flutter channel stable Přepne na stabilní kanál. flutter channel beta Přepne na beta kanál. Diagnostika flutter doctor Zkontroluje nastavení Flutteru a zobrazí seznam chybějících nebo nesprávně nastavených komponent. flutter doctor -v Detailní výstup diagnostiky Flutteru. Závislosti flutter pub get Stáhne závislosti uvedené v souboru pubspec.yaml. flutter pub upgrade Aktualizuje všechny závislosti na nejnovější kompatibilní verze. flutter pub cache repair Opraví a znovu stáhne závislosti uložené v cache. Projektové příkazy flutter create project_name Vytvoří nový Flutter projekt ve složce project_name. flutter run Spustí aplikaci na připojeném zařízení nebo emulátoru. flutter build apk Vytvoří produkční APK soubor aplikace. flutter build ios Vytvoří produkční build pro iOS (vyžaduje macOS a Xcode). flutter clean Odstraní dočasné soubory a vyčistí build cache. flutter test Spustí všechny testy definované v projektu. Zařízení a emulátory flutter devices Zobrazí seznam připojených zařízení a dostupných emulátorů. flutter emulators Zobrazí seznam dostupných emulátorů. flutter emulators --launch emulator_id Spustí specifický emulátor podle jeho ID. flutter install Nainstaluje aplikaci na připojené zařízení. Analýza a opravy dart analyze Spustí analýzu kódu na projektu a zobrazí potenciální chyby nebo varování. dart fix --apply Aplikuje doporučené opravy kódu podle výsledků analýzy. Logy flutter logs Zobrazí logy aplikace z běžící instance Flutteru. Balíčky Lokalizace (interní knihovna) Přidání závislosti do souboru pubspec.yaml: Přidejte flutter_localizations viz. níže: dependencies: # Internal dependencies flutter: sdk: flutter flutter_localizations: sdk: flutter # External dependencies cupertino_icons: ^1.0.8 flutter_svg: ^2.0.16 Vytvořte lokalizační soubory lib/l10n/intl_en.arb, příklad souboru pro anglické texty { \"@@locale\": \"en\", \"hello\": \"Hello\", \"welcome\": \"Welcome\" } lib/l10n/intl_cs.arb, příklad souboru pro české texty { \"@@locale\": \"cs\", \"hello\": \"Ahoj\", \"welcome\": \"Vítejte\" } Note @@locale, definuje jazykovou verzi překladu obsaženou v souboru .arb. Tip Pokud chcete nastavit výchozí lokalizační soubor bez nutnosti mít intl_messages.arb, musíte nastavit výchozí jazyk ve vašem Flutter kódu. // Material design for applications import 'package:flutter/material.dart'; // Localization import 'package:flutter_localizations/flutter_localizations.dart'; import 'generated/l10n.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( localizationsDelegates: [ S.delegate, GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, GlobalCupertinoLocalizations.delegate, ], supportedLocales: S.delegate.supportedLocales, locale: Locale('cs'), // Nastavení výchozího jazyka na češtinu home: MainPage(), ); } } Vygenerovat potřebné lokalizační soubory Přidejte intl_utils do konfiguračního souboru (pubspec.yaml): dependencies: # Internal dependencies flutter: sdk: flutter flutter_localizations: sdk: flutter # External dependencies intl_utils: ^2.5.0 cupertino_icons: ^1.0.8 flutter_svg: ^2.0.16 Spusťte následující příkaz: # Install the dependencies listed in pubspec.yaml dart pub get # Generate the necessary localization files based on the ARB files dart run intl_utils:generate Zobrazení textu z lokalizace import 'package:flutter/material.dart'; // Import package for material design import 'package:flutter_localizations/flutter_localizations.dart'; // Import package for localization import 'generated/l10n.dart'; // Import generated localization file void main() { // Spuštění aplikace runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( // Definování delegátů pro lokalizaci localizationsDelegates: [ S.delegate, // Vlastní generovaný delegát pro lokalizaci GlobalMaterialLocalizations.delegate, // Material design lokalizace GlobalWidgetsLocalizations.delegate, // Widgety lokalizace GlobalCupertinoLocalizations.delegate, // Cupertino (iOS) lokalizace ], // Podporované jazyky supportedLocales: S.delegate.supportedLocales, // Hlavní stránka aplikace home: MainPage(), ); } } class MainPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( // Zobrazení lokalizovaného textu v AppBar title: Text(S.of(context).hello), ), body: Center( // Zobrazení lokalizovaného textu v těle stránky child: Text(S.of(context).welcome), ), ); } } Pokrytí kódů (Code Coverage) Bez nahlédnutí do zdrojového kódu Nainstalujte balíček skrze npm: npm install -g @lcov-viewer/cli Vytvořte nový soubor package.json s výchozími hodnoty: npm init -y Vaše konfigurace bude vypadat podobně takto: { \"name\": \"xxx_app\", \"version\": \"1.0.0\", \"description\": \"A new Flutter project.\", \"main\": \"index.js\", \"directories\": { \"lib\": \"lib\", \"test\": \"test\" }, \"scripts\": { \"test-report\": \" flutter test --coverage && lcov-viewer lcov -o ./coverage/report ./coverage/lcov.info\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" } Spusťte příkaz: npm run test-report S nahlédnutím do zdrojového kódu Stáhněte si soubor genhtml Warning Nové verze genhtml obsahují další závislosti, které mohou být potřeba pro správné fungování. Jedná se o verze 2.0 a vyšší. Dejte soubor genhtml do kořenové složky projektu Ujistěte se, že máte nainstalovaný Git Bash Note S tím se nainstaluje i perl, který je potřeba pro správné fungování genhtml. Spusťte příkaz v Git Bash: where perl Spusťte následující příkaz v Git Bash v kořenové složce projektu: perl genhtml coverage/lcov.info -o coverage/html Řešení problémů Zlepšení chování v kódi Automaticky zmenšit text bez použití doplňků Expanded( child: FittedBox( fit: BoxFit.scaleDown, child: Text('${widget.article.price * chosenQuantity} DH', style: const TextStyle(fontSize: 25 , fontWeight: FontWeight.w700), ), ), ), Analýza kódu napříč IDE Vypnutí pravida \"no_logic_in_create_state\" Otevřete soubor analysis_options.yaml Tento soubor by měl být umístěn v kořenovém adresáři vašeho projektu. Note Pokud soubor nemáte, můžete ho vytvořit v hlavním adresáři projektu. Přidejte sekci linter Pokud v souboru ještě není definovaná sekce linter, přidejte ji spolu s pravidly. Příklad: linter: rules: no_logic_in_create_state: false Uložte soubor Restartujte IDE Po restartu by mělo být pravidlo no_logic_in_create_state vypnuto a měli byste být schopni používat logiku v metodě createState() bez varování. Spuštění aplikace Building with plugins requires symlink support. Pokud se vyskytne chyba Building with plugins requires symlink support. při spuštění aplikace, je potřeba povolit Developer Mode v systému Windows. Stiskněte klávesovou zkratku Win + R Zadejte ms-settings:developers a stiskněte Enter Povolte Developer Mode"
  },
  "programming/net.html": {
    "href": "programming/net.html",
    "title": "| Vývojář",
    "summary": "Modifikátory přístupu Určuje přístup k danému prvku. Caller's location public protected internal protected internal private protected private file Within the file ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ Within the class ✔️ ✔️ ✔️ ✔️ ✔️ ✔️ ❌ Derived class (same assembly) ✔️ ✔️ ✔️ ✔️ ✔️ ❌ ❌ Non-derived class (same assembly) ✔️ ✔️ ❌ ✔️ ❌ ❌ ❌ Derived class (different assembly) ✔️ ✔️ ✔️ ❌ ❌ ❌ ❌ Non-derived class (different assembly) ✔️ ❌ ❌ ❌ ❌ ❌ ❌ Více podrobností zde. Složka 'runtimes' a multiplatformní nasazení Slouží k ukládání platformově specifických knihoven a binárních souborů, které jsou nezbytné pro správné spuštění aplikace na různých operačních systémech a architekturách. Používá se v aplikacích: WPF aplikace Konzolové aplikace ASP.NET Core aplikace WinForms aplikace .NET knihovny a služby, které se nasazují na různé platformy (Windows, Linux, macOS, atd.) Tip V unity se používá složka 'Plugins' k umístění knihoven (DLL), které jsou platformově specifické Tato složka může obsahovat nativní kód pro různé platformy (Windows, Android, iOS, macOS, atd.) Tato složka 'runtime' se automaticky generuje při publikaci aplikace a hraje zásadní roli zejména při použití dvou typů nasazení. Každý z těchto typů nasazení určuje, jakým způsobem aplikace zajišťuje dostupnost .NET runtime a dalších závislostí: self-contained deployment Aplikace je distribuována společně s kompletním .NET runtime To znamená, že aplikace si nese vlastní runtime a může běžet nezávisle na tom, zda má uživatel na svém systému nainstalovaný správný .NET runtime. Tip Toto nasazení je vhodné, pokud chcete zajistit, že aplikace poběží na jakémkoliv počítači, bez ohledu na její aktuální stav. Výsledkem je větší velikost aplikace, protože obsahuje kompletní runtime pro cílové platformy, které jsou zahrnuty ve složce 'runtimes'. V praxi složka 'runtimes' obsahuje potřebné knihovny a binární soubory pro různé platformy, jako jsou Windows, Linux, macOS, nebo různé architektury (x64, x86, ARM). Díky tomu může aplikace běžet out-of-the-box bez nutnosti další instalace runtime na cílovém systému. Použití Nastavit v souboru projektu (.csproj): <PropertyGroup> <SelfContained>true</SelfContained> <RuntimeIdentifier>win-x64</RuntimeIdentifier> <!-- Nebo jiný RID podle platformy --> </PropertyGroup> nebo s více Runtime Identifiers (RID) <PropertyGroup> <SelfContained>true</SelfContained> <RuntimeIdentifiers>win-x64;linux-x64;osx-x64</RuntimeIdentifiers> </PropertyGroup> Note Runtime Identifiers (RID) Runtime Identifiers (RID) jsou klíčovou součástí procesu nasazení, protože určují, pro jaké platformy a architektury bude aplikace kompilována. Můžete specifikovat různé RID podle cílové platformy: win-x64 (Windows 64-bit) linux-x64 (Linux 64-bit) osx-x64 (macOS 64-bit) win-arm (Windows na ARM procesorech) framework-dependent deployment (runtime-specific deployment) Aplikace závisí na přítomnosti .NET runtime na cílovém systému. Aplikace neobsahuje runtime v sobě, což zmenšuje její velikost, ale předpokládá, že uživatel má již správnou verzi .NET runtime nainstalovanou. Important Pokud runtime není přítomen, aplikace nefunguje, dokud uživatel runtime nedoinstaluje. V tomto případě složka \"runtimes\" může obsahovat pouze platformově specifické knihovny a závislosti, které nejsou součástí základního .NET runtime, a zajistit kompatibilitu aplikace s různými platformami. Použití Note Nastavte SelfContained na false, nebo tuto vlastnost úplně vynechte (výchozí nastavení je totiž framework-dependent). Nastavit v souboru projektu (.csproj): <PropertyGroup> <SelfContained>false</SelfContained> </PropertyGroup> Uvolnění zdrojů Řízené zdroje = Objekty, které jsou spravovány garbage collectorem. Zahrnuje všechny objekty vytvořené pomocí klíčového slova new. Garbage collector automaticky sleduje tyto objekty a uvolňuje jejich paměť, když již nejsou potřebné. Tip Programátoři nemusí explicitně uvolňovat paměť pro tyto objekty. Neřízené zdroje = Objekty, které nejsou spravovány garbage collectorem. Zahrnuje soubory, databázové připojení, síťové zdroje, atd... Note Programátoři musí explicitně uvolnit tyto zdroje, aby zabránili úniku paměti. Uvolnění zdrojů je důležité pro správné fungování aplikace. Destruktor Automaticky volán, když je objekt zničen garbage collectorem. Definuje se pomocí syntaxe ~ClassName(). Uvolňuje neřízené zdroje, které třída drží. Destruktory nejsou deterministické. Tip Znamená, že nevíme přesně, kdy budou volány. Jsou volány, když garbage collector rozhodne, že je objekt vhodný ke zničení. Note Může to být kdykoliv po tom, co objekt přestane být používán. Dispose Součástí rozhraní IDisposable a je určen pro explicitní uvolnění zdrojů. Metoda Dispose je volána programátorem, když je známo, že objekt již nebude potřebný. Note To umožňuje okamžité uvolnění zdrojů a zajišťuje, že nebudou drženy déle, než je nutné. Metoda Dispose je určena pro uvolnění jak řízených, tak neřízených zdrojů. Volání funkcí z externích DLL Note Platform Invocation Services (PInvoke) se používá pro volání knihoven z nativního kódu. Nativní kód = Kód kompilován do strojového kódu pro konkrétní platformu. Strojový kód = Kód přímo spustitelný na hardware dané platformy. Postup: Importování funkce z DLL Atribut DllImport z System.Runtime.InteropServices k importování funkce z DLL. Například: using System.Runtime.InteropServices; public class MyProgram { [DllImport(\"User32.dll\")] public static extern int MessageBox(IntPtr h, string m, string c, int type); } Note MessageBox je funkce definovaná v knihovně: User32.dll. Tato funkce je nyní dostupná v rámci tohoto .NET kódu. Příklad knihovny v c++ Knihovna v c++ by mohla vypadat takto: #include <windows.h> extern \"C\" __declspec(dllexport) int MessageBox(HWND h, LPCSTR m, LPCSTR c, int type) { return MessageBoxA(h, m, c, type); } Metody a argumenty v c++ extern \"C\" Warning Zajistí, že funkce jsou kompatibilní s C jazykem. (To je důležité pro interoperabilitu mezi C++ a jinými jazyky, jako je C#.) Tip Když kompilátor narazí na funkci, změní její název na něco, co jednoznačně identifikuje nejen název funkce, ale také typy jejích parametrů. To znamená, že název funkce, jak je viděn v DLL, nebude stejný jako název funkce v původním kódu. Když použijete extern \"C\", říkáte kompilátoru, aby tuto funkci nezměnil a zachoval její název tak, jak je. To umožňuje jiným jazykům, jako je C#, najít a volat tuto funkci správným názvem. __declspec(dllexport) Říka kompilátoru C++, že tato funkce nebo proměnná bude exportována z DLL, takže ji může volat jiný kód, který tuto DLL používá. Warning Důležité k viditelnosti a dostupnosti pro PInvoke HWND \"handle to a window\" (rukojeť okna) LPCTSTR \"Long Pointer Constant String\" | Item | 8-bitů (Ansi) | 16-bitů (Wide) | Různé | > |----------------|---------------|----------------|---------| | character | CHAR | WCHAR | TCHAR | | string | LPSTR | LPWSTR | LPTSTR | | string (const) | LPCSTR | LPCWSTR | LPCTSTR | Odkaz zde Volání importované funkce public class MyProgram { public static void Main() { MessageBox(IntPtr.Zero, \"Hello, World!\", \"Test MessageBox\", 0); } } IntPtr.Zero Konstanta, která reprezentuje nulový ukazatel. Je to ekvivalent NULL v C++. __Internal Pokud se používá __Internal jako název DLL v atributu DllImport, znamená to, že funkce se hledá přímo v hlavním spustitelném souboru. Tip Hledá tedy v samotné aplikaci, pokud je to nativní kód, nebo v jedné z knihoven, na které aplikace odkazuje. Příklad použití v C#: > > ```csharp public class MyProgram { [DllImport(\"__Internal\")] public static extern int MyFunction(); public static void Main() { MyFunction(); } } Příklad definice v C++ > > ```c++ extern \"C\" __declspec(dllexport) int MyFunction() { // Implementace vaší funkce return 0; } > > V tomto příkladu `MyFunction` je funkce definovaná v nativním kódu. > > Je tedy součástí aplikace nebo jedné z jejích závislostí. Tipy PInvoke = Platform Invocation Services, což je technika v .NET, která umožňuje volání funkcí, které jsou implementovány v neřízeném kódu. Tip To je obvykle používáno pro volání C API funkcí, které jsou definovány v DLL. Příklad: private static class PInvoke { #if UNITY_IOS || UNITY_TVOS private const string DllName = \"__Internal\"; #elif UNITY_STANDALONE_OSX private const string DllName = \"MacOSAppleAuthManager\"; #endif public delegate void NativeMessageHandlerCallbackDelegate(uint requestId, string payload); [AOT.MonoPInvokeCallback(typeof(NativeMessageHandlerCallbackDelegate))] public static void NativeMessageHandlerCallback(uint requestId, string payload) { try { CallbackHandler.ScheduleCallback(requestId, payload); } catch (Exception exception) { Console.WriteLine(\"Received exception while scheduling a callback for request ID \" + requestId); Console.WriteLine(\"Detailed payload:\\n\" + payload); Console.WriteLine(\"Exception: \" + exception); } } [System.Runtime.InteropServices.DllImport(DllName)] public static extern bool AppleAuth_IsCurrentPlatformSupported(); [System.Runtime.InteropServices.DllImport(DllName)] public static extern void AppleAuth_SetupNativeMessageHandlerCallback(NativeMessageHandlerCallbackDelegate callback); [System.Runtime.InteropServices.DllImport(DllName)] public static extern void AppleAuth_GetCredentialState(uint requestId, string userId); [System.Runtime.InteropServices.DllImport(DllName)] public static extern void AppleAuth_LoginWithAppleId(uint requestId, int loginOptions, string nonceCStr, string stateCStr); [System.Runtime.InteropServices.DllImport(DllName)] public static extern void AppleAuth_QuickLogin(uint requestId, string nonceCStr, string stateCStr); [System.Runtime.InteropServices.DllImport(DllName)] public static extern void AppleAuth_RegisterCredentialsRevokedCallbackId(uint callbackId); [System.Runtime.InteropServices.DllImport(DllName)] public static extern void AppleAuth_LogMessage(string messageCStr); } Více info zde."
  },
  "programming/net/net_attributes.html": {
    "href": "programming/net/net_attributes.html",
    "title": "| Vývojář",
    "summary": "Atributy obsahujá Metadata Datové anotace = System.ComponentModel.Annotations (namespace) Nejvíce používané anotace: [Required] Hodnota je povinná [Range] Hodnota v číselném rozsahu [MaxLength] Hodnota s maximální délkou [MinLength] Hodnota s minimální délkou [StringLength] Hodnota s maximální a volitelnou minimální délkou [RegularExpression] Ověření hodnoty z regulárního výrazu [DataType] Specifikuje datový typ pro hodnotu [Display] Název a pořadí hodnoty Příklad Definice public class Author { [Required(ErrorMessage = \"{0} is required\")] [StringLength(50, MinimumLength = 3, ErrorMessage = \"First Name should be minimum 3 characters and a maximum of 50 characters\")] [DataType(DataType.Text)] public string FirstName { get; set; } [Required(ErrorMessage = \"{0} is required\")] [StringLength(50, MinimumLength = 3, ErrorMessage = \"Last Name should be minimum 3 characters and a maximum of 50 characters\")] [DataType(DataType.Text)] public string LastName { get; set; } [DataType(DataType.PhoneNumber)] [Phone] public string PhoneNumber { get; set; } [DataType(DataType.EmailAddress)] [EmailAddress] public string Email { get; set; } } Použití Author author = new Author(); author.FirstName = \"Joydip\"; author.LastName = \"\"; author.PhoneNumber = \"1234567890\"; author.Email = \"joydipkanjilal@yahoo.com\"; // Provedení kontroly dat ValidationContext context = new ValidationContext(author, null, null); List<ValidationResult> validationResults = new List<ValidationResult>(); bool valid = Validator.TryValidateObject(author, context, validationResults, true); if (!valid) { foreach (ValidationResult validationResult in validationResults) { Console.WriteLine(\"{0}\", validationResult.ErrorMessage); } } Vlastní datová anotace Vytvořit třídu a rozšířit ji o třídu ValidationAttribute Přepsat metodu IsValid Definice [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)] public class IsEmptyAttribute : ValidationAttribute { public override bool IsValid(object value) { var inputValue = value as string; return !string.IsNullOrEmpty(inputValue); } } Použití [IsEmpty(ErrorMessage = \"Should not be null or empty.\")] public string FirstName { get; set; } [IsEmpty(ErrorMessage = \"Should not be null or empty.\")] public string LastName { get; set; } FileHelpers Important Nepodporuje: Záznamy s proměnnou délkou (každý záznam musí mít stejný počet polí) Změnu formátu za běhu ( každý záznam musí mít stejný formát po celou dobu běhu programu) Nejvíce používané atributy: Třída [DelimitedRecord] Záznamy s oddělovači. [FixedLengthRecord] Záznamy s pevnou délkou. Pole [FieldTrim] Odstranění bílých znaků z hodnoty. [FieldOptional] Volitelný sloupec. Pokud sloupec v souboru chybí, nebude to považováno za chybu. [FieldIgnore] Ignoruje sloupec při čtení nebo zápisu souboru. [FieldConverter] Přiřazení konvertoru. Konvertor = třída, převádí hodnoty mezi textovou reprezentací v souboru a hodnotou v datech. [FieldOrder] Určuje pořadí sloupců pro čtení nebo zápis souboru. [FieldQuoted] Pokud je hodnota v souboru uvedena v uvozovkách. Příklad Definice třídy pro záznamy Soubory s oddělovači: [DelimitedRecord(\",\")] Soubory s pevnou délkou záznamu: [FixedLengthRecord] Přečíst nebo zapsat soubor Čtení ze souboru: var engine = new FileHelperEngine<Order>(); Order[] result = engine.ReadFile(\"Input.txt\"); Zápis do souboru: var engine = new FileHelperEngine<Order>(); engine.WriteFile(\"Output.txt\", result); Vlastní konvertor Vytvořit třídu a rozšířit ji o třídu ConverterBase. Přepsat metody StringToField a FieldToString. Příklad: Definice public class MyCustomConverter : ConverterBase { public override object StringToField(string from) { // Převeďte řetězec na objekt } public override string FieldToString(object fieldValue) { // Převeďte objekt na řetězec } } Použití [DelimitedRecord(\",\")] public class Order { [FieldConverter(typeof(MyCustomConverter))] public int OrderID; // ... }"
  },
  "programming/net/net_conversion.html": {
    "href": "programming/net/net_conversion.html",
    "title": "| Vývojář",
    "summary": "Implicitní a Explicitní operátory Rozdíly: Implicitní: Automatický převod (žádný cast není potřeba) Explicitní: Vyžaduje cast (musíte převod jasně napsat) Note Implicitní je pohodlnější, ale explicitní je bezpečnější pro složité nebo nejednoznačné převody. Implicitní operátor Automatický převod mezi typy. (Není potřeba nic speciálně psát, převod se provede sám.) Příklad: public struct Money { private double _value; public Money(double value) { _value = value; } public static implicit operator double(Money money) { return money._value; } } // Použití Money m = new Money(10.50); double d = m * 2; // Automaticky převede Money na double Explicitní operátor Vyžaduje použití castu, například: (double). (Převod není automatický, musíte ho sami zadat.) Příklad: public struct Temperature { private double _value; public Temperature(double value) { _value = value; } public static explicit operator double(Temperature temperature) { return temperature._value; } } // Použití Temperature t = new Temperature(70.0); double d = (double)t + 32.0; // Explicitně převedete Temperature na double"
  },
  "programming/net/net_createAPI.html": {
    "href": "programming/net/net_createAPI.html",
    "title": "| Vývojář",
    "summary": "Vytvoření API Vlastní REST API v C# s využitím frameworku ASP.NET Core. Vytvoření projektu Otevřete Visual Studio. Vyberte možnost Create a new project. Zvolte šablonu ASP.NET Core Web API. Pojmenujte projekt a klikněte na Create. Vyberte .NET 6 (Long-term support) nebo nejnovější dostupnou verzi .NET a potvrďte. Struktura projektu Složka/Soubor Popis Controllers Obsahuje kontrolery API. Program.cs Hlavní vstupní bod aplikace. appsettings.json Konfigurační soubor. Přidání kontroleru Klikněte pravým tlačítkem na složku Add → Controller.... Vyberte MVC Controller - Empty a pojmenujte ho např. MyController. using Microsoft.AspNetCore.Mvc; namespace MyAPI.Controllers { // Třída MyController je použita jako \"my\" v URL trasách // To je způsobeno tím, že atribut [Route(\"api/[controller]\")] používá název třídy kontroleru (bez přípony \"Controller\") jako prefix trasy. [ApiController] // Definuje třídu jako API kontroler. [Route(\"api/[controller]\")] // Definuje prefix URL pro kontroler. public class MyController : ControllerBase { // GET: api/my [HttpGet] // Definuje metodu jako GET. public IActionResult Get() { return Ok(new { message = \"Vítejte v mém API!\" }); // Vrátí HTTP 200 OK s objektem. } // POST: api/my [HttpPost] // Definuje metodu jako POST. public IActionResult Post([FromBody] MyModel model) // Označuje, že parametr metody je z těla požadavku. { if (model == null) { return BadRequest(\"Model je null\"); // Vrátí HTTP 400 Bad Request s objektem. } return CreatedAtAction(nameof(Get), new { id = model.Id }, model); // Vrátí HTTP 201 Created s objektem. } // PUT: api/my/{id} [HttpPut(\"{id}\")] // Definuje metodu jako PUT. public IActionResult Put(int id, [FromBody] MyModel model) // Označuje, že parametr metody je z těla požadavku. { if (id != model.Id) { return BadRequest(\"ID neodpovídá\"); // Vrátí HTTP 400 Bad Request s objektem. } // Aktualizace logiky zde return Ok(model); // Vrátí HTTP 200 OK s objektem. } // DELETE: api/my/{id} [HttpDelete(\"{id}\")] // Definuje metodu jako DELETE. public IActionResult Delete(int id) { // Smazání logiky zde return NoContent(); // Vrátí HTTP 204 No Content. } // GET: api/my/search?query={query} [HttpGet(\"search\")] // Definuje metodu jako GET. public IActionResult Search([FromQuery] string query) // Označuje, že parametr metody je z dotazu URL. { // Vyhledávací logika zde return Ok(new { query }); // Vrátí HTTP 200 OK s objektem. } // GET: api/my/{id} [HttpGet(\"{id}\")] // Definuje metodu jako GET. public IActionResult GetById([FromRoute] int id) // Označuje, že parametr metody je z cesty URL. { // Získání logiky zde var model = new MyModel { Id = id, Name = \"Example\" }; if (model == null) { return NotFound(); // Vrátí HTTP 404 Not Found. } return Ok(model); // Vrátí HTTP 200 OK s objektem. } } public class MyModel { public int Id { get; set; } public string Name { get; set; } } } Konfigurace závislostí Soubor Startup.cs slouží k nastavení a konfiguraci aplikace. `Startup.cs` using Microsoft.AspNetCore.Builder; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.AspNetCore.Http; using Microsoft.Extensions.Logging; namespace MyAPI { public class Startup { /// <summary> Obsahuje konfiguraci aplikace. </summary> private readonly IConfiguration _configuration; /// <summary> Inicializuje novou instanci třídy <see cref=\"Startup\"/>. </summary> public Startup(IConfiguration configuration) { _configuration = configuration; // Uloží konfiguraci do privátní proměnné. } /// <summary> /// Konfiguruje služby pro aplikaci. /// /// Zde se přidávají služby do kontejneru služeb, které jsou následně použíty v <see cref=\"Configure\"/>. /// </summary> /// <param name=\"services\">Kolekce služeb pro aplikaci.</param> public void ConfigureServices(IServiceCollection services) { // Přidává službu MVC. // MVC = Model-View-Controller, architektura pro vytváření webových aplikací. services.AddControllers(); // Příklad použití konfigurace z appsettings.json // Přidává podporu pro CORS. // (CORS = Cross-Origin Resource Sharing, umožňuje webům získat data ze serverů na jiné doméně, pokud to server povolí.) services.AddCors(); // Přidává podporu pro autentizaci. // Aplikace může používat různé způsoby autentizace, např. OAuth, OpenID Connect, Cookies, JWT atd. services.AddAuthentication(); // Přidává podporu pro autorizaci. // Autorizace určuje, kdo může přistupovat k různým částem aplikace. services.AddAuthorization(); // Přidává podporu pro Swagger (dokumentace API). // Swagger je nástroj pro vytváření, dokumentaci a testování API. services.AddSwaggerGen(); // Příklad použití konfigurace v třídě služby. services.AddSingleton<MyService>(); } /// <summary> /// Konfiguruje middleware a další nastavení aplikace. /// </summary> /// <param name=\"app\">Aplikace pro konfiguraci middleware.</param> /// <param name=\"env\">Poskytuje informace o prostředí, ve kterém aplikace běží.</param> /// <param name=\"logger\">Poskytuje funkce pro logování.</param> /// <param name=\"myService\">Poskytuje službu pro konfiguraci.</param> public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILogger<Startup> logger, MyService myService) { // Přidává middleware pro logování chyb. if (env.IsDevelopment()) { // Povoluje stránku s chybami pro vývojové prostředí. app.UseDeveloperExceptionPage(); } else { // Používá stránku s chybami pro produkční prostředí. app.UseExceptionHandler(\"/Home/Error\"); app.UseHsts(); // HSTS = HTTP Strict Transport Security, zajišťuje, že prohlížeči budou komunikovat pouze přes HTTPS. } // Přidává podporu pro HTTPS. app.UseHttpsRedirection(); // Přidává podporu pro statické soubory. app.UseStaticFiles(); // Přidává podporu pro CORS. app.UseCors(builder => builder.AllowAnyOrigin() // Povoluje všechny zdroje. .AllowAnyMethod() // Povoluje všechny metody. .AllowAnyHeader()); // Povoluje všechny hlavičky. // Přidává podporu pro routování. // Routování určuje, jaké akce budou provedeny pro různé URL adresy. app.UseRouting(); // Přidává podporu pro autentizaci. app.UseAuthentication(); // Přidává podporu pro autorizaci. app.UseAuthorization(); // Přidává podporu pro Swagger. app.UseSwagger(); app.UseSwaggerUI(c => { // Nastavuje prefix URL pro Swagger. // Pokud je nastaveno na prázdný řetězec, Swagger UI bude dostupné na kořenové URL (např. https://localhost:5001/). c.RoutePrefix = string.Empty; // Přidává endpoint pro Swagger. // Definuje URL, kde bude dostupná specifikace Swagger (např. https://localhost:5001/v1/swagger.json). c.SwaggerEndpoint(\"v1/swagger.json\", \"My API V1\"); }); // Přidává middleware pro logování požadavků. app.Use(async (context, next) => { // Příklad použití služby s konfigurací. myService.LogInformation(); myService.UseApiKeys(); // Loguje informace o požadavku. logger.LogInformation(\"Handling request: \" + context.Request.Path); // Předává řízení dalšímu middleware. await next.Invoke(); // Loguje informace o dokončení požadavku. logger.LogInformation(\"Finished handling request.\"); }); // Přidává middleware pro routování pro kontrolery. app.UseEndpoints(endpoints => { // Přidává routování pro kontrolery. endpoints.MapControllers(); }); } } } Soubor Program.cs obsahuje vstupní bod aplikace. `Program.cs` public class Program { public static void Main(string[] args) { // Vytvoří a spustí hostitele aplikace. CreateHostBuilder(args).Build().Run(); } /// <summary> /// Vytvoří hostitele pro aplikaci. /// </summary> /// <param name=\"args\">Argumenty příkazového řádku.</param> public static IHostBuilder CreateHostBuilder(string[] args) { // Vytvoří hostitele pro aplikaci. return Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder => { // Konfiguruje hostitele pro aplikaci. webBuilder.UseStartup<Startup>(); }); } } Soubor appsettings.json obsahuje konfiguraci aplikace. `appsettings.json` { // Pevné konfigurace \"Logging\": { \"LogLevel\": { \"Default\": \"Information\", // Výchozí úroveň logování }, \"Console\": { \"IncludeScopes\": true // Zahrnuje rozsahy logování. (Zahrnuje informace o třídě, která loguje zprávu.) } }, \"AllowedHosts\": \"*\", // Povolené hostitelské adresy \"ConnectionStrings\": { // Konfigurace připojení k databázi \"DefaultConnection\": \"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;\", // Custom // Další připojení k databázi \"AnotherConnection\": \"Server=anotherServerAddress;Database=anotherDataBase;User Id=anotherUsername;Password=anotherPassword;\" // Custom }, // Příklad vlastní konfigurace pro modely a služby \"CustomSettings\": { \"EmailSettings\": { \"SmtpServer\": \"smtp.example.com\", \"SmtpPort\": 587, \"SenderName\": \"Example App\", \"SenderEmail\": \"noreply@example.com\", \"Username\": \"smtpUser\", \"Password\": \"smtpPassword\" }, \"ThirdPartyApiKeys\": { \"GoogleMaps\": \"your-google-maps-api-key\", \"SendGrid\": \"your-sendgrid-api-key\" } } } Příklad použití konfigurace v třídě služby. public class MyService { private readonly IConfiguration _configuration; private readonly ILogger<MyService> _logger; private readonly string _defaultConnectionString; private readonly string _anotherConnectionString; private readonly EmailSettings _emailSettings; private readonly ThirdPartyApiKeys _apiKeys; public MyService(IConfiguration configuration, ILogger<MyService> logger) { _configuration = configuration; _logger = logger; // Načtení připojovacích řetězců _defaultConnectionString = _configuration.GetConnectionString(\"DefaultConnection\"); _anotherConnectionString = _configuration.GetConnectionString(\"AnotherConnection\"); // Načtení vlastních nastavení _emailSettings = _configuration.GetSection(\"CustomSettings:EmailSettings\").Get<EmailSettings>(); _apiKeys = _configuration.GetSection(\"CustomSettings:ThirdPartyApiKeys\").Get<ThirdPartyApiKeys>(); } public void LogInformation() { _logger.LogInformation(\"Default connection string: {ConnectionString}\", _defaultConnectionString); _logger.LogInformation(\"Another connection string: {ConnectionString}\", _anotherConnectionString); } public void SendEmail() { // Příklad použití EmailSettings var smtpClient = new SmtpClient(_emailSettings.SmtpServer, _emailSettings.SmtpPort) { Credentials = new NetworkCredential(_emailSettings.Username, _emailSettings.Password), EnableSsl = true }; var mailMessage = new MailMessage { From = new MailAddress(_emailSettings.SenderEmail, _emailSettings.SenderName), Subject = \"Test Email\", Body = \"This is a test email.\", IsBodyHtml = true, }; mailMessage.To.Add(\"recipient@example.com\"); smtpClient.Send(mailMessage); } public void UseApiKeys() { // Příklad použití ThirdPartyApiKeys var googleMapsApiKey = _apiKeys.GoogleMaps; var sendGridApiKey = _apiKeys.SendGrid; _logger.LogInformation(\"Google Maps API Key: {ApiKey}\", googleMapsApiKey); _logger.LogInformation(\"SendGrid API Key: {ApiKey}\", sendGridApiKey); } } public class EmailSettings { public string SmtpServer { get; set; } public int SmtpPort { get; set; } public string SenderName { get; set; } public string SenderEmail { get; set; } public string Username { get; set; } public string Password { get; set; } } public class ThirdPartyApiKeys { public string GoogleMaps { get; set; } public string SendGrid { get; set; } }"
  },
  "programming/net/net_dataTypes.html": {
    "href": "programming/net/net_dataTypes.html",
    "title": "| Vývojář",
    "summary": "Kolekce FIFO/LIFO Určují pořadí, ve kterém jsou prvky přidávány a odebírány. Queue = Fronta Funguje na principu FIFO (First In First Out) = První prvek, který je vložen do fronty, je první, který je vyjmut. Note Představte si frontu jako řadu lidí čekajících na autobus. První člověk, který přišel (enqueue), je první, kdo nastoupí do autobusu (dequeue). Příklad: Queue<int> queue = new Queue<int>(); queue.Enqueue(1); // Enqueue() vloží prvek do fronty queue.Enqueue(2); queue.Enqueue(3); Console.WriteLine(queue.Dequeue()); // Dequeue() vyjme první prvek z fronty: 1 Console.WriteLine(queue.Dequeue()); // 2 Console.WriteLine(queue.Dequeue()); // 3 PriorityQueue Každý prvek ve frontě má přiřazenou prioritu. Prvek s nejvyšší prioritou je vždy vyjmut první. Příklad: PriorityQueue<int> queue = new PriorityQueue<int>(); queue.Enqueue(1, 2); // Enqueue() vloží prvek do fronty s prioritou 2 queue.Enqueue(2, 1); // Prvek s prioritou 1 bude vyjmut první queue.Enqueue(3, 3); Console.WriteLine(queue.Dequeue()); // 2 Console.WriteLine(queue.Dequeue()); // 1 Console.WriteLine(queue.Dequeue()); // 3 Stack = Zásobník Funguje na principu LIFO (Last In First Out) = Poslední prvek, který je vložen do zásobníku, je první, který je vyjmut. Note Představte si zásobník jako hromadu talířů. Poslední talíř, který je položen na hromadu (push), je první, který je vyjmut (pop). Příklad: Stack<int> stack = new Stack<int>(); stack.Push(1); // Push() vloží prvek na zásobník stack.Push(2); stack.Push(3); Console.WriteLine(stack.Pop()); // Pop() vyjme poslední prvek ze zásobníku: 3 Console.WriteLine(stack.Pop()); // 2 Console.WriteLine(stack.Pop()); // 1 Seznamy Seznamy jsou kolekce prvků, které lze indexovat a efektivně upravovat. Umožňují přidávání, odstraňování a přístup k prvkům na základě jejich indexu. List Seznam prvků, který lze indexovat. Příklad: List<int> list = new List<int>(); list.Add(1); // Add() přidá prvek na konec seznamu list.Add(2); list.Add(3); Console.WriteLine(list[1]); // Vrátí prvek na indexu 1: 2 list.RemoveAt(1); // RemoveAt() odebere prvek na indexu 1 Console.WriteLine(list[1]); // 3 LinkedList Seznam prvků, který lze efektivně upravovat. Příklad: LinkedList<int> linkedList = new LinkedList<int>(); linkedList.AddLast(1); // AddLast() přidá prvek na konec seznamu linkedList.AddLast(2); linkedList.AddLast(3); Console.WriteLine(linkedList.First.Value); // Vrátí první prvek seznamu: 1 linkedList.RemoveFirst(); // RemoveFirst() odebere první prvek ze seznamu Console.WriteLine(linkedList.First.Value); // 2 Slovníky Slovníky jsou kolekce klíč-hodnota, které umožňují efektivní vyhledávání, přidávání a odstraňování prvků na základě klíče. Každý klíč v slovníku je jedinečný a je spojen s jednou hodnotou. Dictionary Kolekce klíč-hodnota, která je efektivní pro vyhledávání. Příklad: Dictionary<string, int> dictionary = new Dictionary<string, int>(); dictionary.Add(\"key1\", 1); // Add() přidá klíč a hodnotu do slovníku dictionary.Add(\"key2\", 2); dictionary.Add(\"key3\", 3); Console.WriteLine(dictionary[\"key2\"]); // Vrátí hodnotu pod klíčem \"key2\": 2 dictionary.Remove(\"key2\"); // Remove() odebere klíč a hodnotu ze slovníku Console.WriteLine(dictionary.ContainsKey(\"key2\")); // false Note Je efektivní pro vyhledávání, ale méně efektivní pro úpravy. SortedDictionary Kolekce klíč-hodnota, která je automaticky seřazena podle klíčů. Příklad: SortedDictionary<string, int> sortedDictionary = new SortedDictionary<string, int>(); sortedDictionary.Add(\"key3\", 3); // Add() přidá klíč a hodnotu do tabulky sortedDictionary.Add(\"key1\", 1); sortedDictionary.Add(\"key2\", 2); Console.WriteLine(sortedDictionary.First().Key); // Vrátí klíč prvního prvku: \"key1\" sortedDictionary.Remove(\"key1\"); // Remove() odebere klíč a hodnotu z tabulky Console.WriteLine(sortedDictionary.First().Key); // \"key2\" Note Rozdíl proti Dictionary je, že SortedDictionary je automaticky seřazený podle klíčů. Kolekce bez duplicit Neumožňují ukládání duplicitních prvků HashSet Množina prvků, která neobsahuje duplicitní prvky. Warning Není zaručeno, že prvky budou v množině ve stejném pořadí, jak byly přidány. Příklad: HashSet<int> hashSet = new HashSet<int>(); hashSet.Add(1); // Add() přidá prvek do množiny hashSet.Add(2); hashSet.Add(3); Console.WriteLine(hashSet.Contains(2)); // Contains() zjistí, zda množina obsahuje prvek: true hashSet.Remove(2); // Remove() odebere prvek z množiny Console.WriteLine(hashSet.Contains(2)); // false Note HashSet je optimalizovaný pro rychlé vyhledávání. Hashtable Kolekce klíč-hodnota. Příklad: Hashtable hashtable = new Hashtable(); hashtable.Add(\"key1\", 1); // Add() přidá klíč a hodnotu do tabulky hashtable.Add(\"key2\", 2); hashtable.Add(\"key3\", 3); Console.WriteLine(hashtable[\"key2\"]); // Vrátí hodnotu pod klíčem \"key2\": 2 hashtable.Remove(\"key2\"); // Remove() odebere klíč a hodnotu z tabulky Console.WriteLine(hashtable.Contains(\"key2\")); // false Warning Hashtable je starší třída a je obecně doporučováno používat Dictionary Kolekce Tuple Umožňuje ukládání prvků různých typů v jedné kolekci. Každý prvek v Tuple je přístupný pomocí pevně daného pořadí. Tuple Kolekce prvků různých typů. Příklad: Tuple<int, string> tuple = new Tuple<int, string>(1, \"Hello\"); Console.WriteLine(tuple.Item1); // Vrátí první prvek: 1 Console.WriteLine(tuple.Item2); // Vrátí druhý prvek: \"Hello\" Note Tuple je obecný typ, který lze použít pro vytvoření kolekce prvků různých typů. ValueTuple Kolekce prvků různých typů, která je optimalizovaná pro rychlé vytváření. Příklad: (int, string) valueTuple = (1, \"Hello\"); Console.WriteLine(valueTuple.Item1); // Vrátí první prvek: 1 Console.WriteLine(valueTuple.Item2); // Vrátí druhý prvek: \"Hello\" Tip Vlastní názvy prvků: var tuple = (Shield: 1, Sword: \"Hello\"); Console.WriteLine(tuple.Shield); // Vrátí první prvek: 1 Console.WriteLine(tuple.Sword); // Vrátí druhý prvek: \"Hello\" Note ValueTuple je optimalizovaný typ, který lze použít pro rychlé vytváření kolekce prvků různých typů. Pozorovatelné kolekce Upozorňují na změny prvků, což je užitečné pro sledování změn v reálném čase. ObservableCollection Kolekce, která upozorní na změnu prvků. Příklad: ObservableCollection<int> observableCollection = new ObservableCollection<int>(); observableCollection.CollectionChanged += (sender, e) => { Console.WriteLine(\"Collection changed\"); }; observableCollection.Add(1); // Přidá prvek do kolekce Note ObservableCollection je užitečná pro sledování změn v kolekci. Kolekce pouze pro čtení Kolekce, které nelze měnit po jejich vytvoření, což zajišťuje jejich neměnnost a bezpečnost ReadOnlyCollection Kolekce, kterou nelze měnit. Příklad: List<int> list = new List<int> { 1, 2, 3 }; ReadOnlyCollection<int> readOnlyCollection = new ReadOnlyCollection<int>(list); Console.WriteLine(readOnlyCollection[1]); // Vrátí prvek na indexu 1: 2 Note ReadOnlyCollection je kolekce, kterou nelze měnit. ReadOnlyDictionary Kolekce klíč-hodnota, kterou nelze měnit. Příklad: Dictionary<string, int> dictionary = new Dictionary<string, int> { { \"key1\", 1 }, { \"key2\", 2 }, { \"key3\", 3 } }; ReadOnlyDictionary<string, int> readOnlyDictionary = new ReadOnlyDictionary<string, int>(dictionary); Console.WriteLine(readOnlyDictionary[\"key2\"]); // Vrátí hodnotu pod klíčem \"key2\": 2 Note ReadOnlyDictionary je kolekce klíč-hodnota, kterou nelze měnit. Neměnné kolekce Nelze měnit po jejich vytvoření, což zajišťuje jejich neměnnost a bezpečnost ImmutableArray Pole, které nelze měnit. Příklad: ImmutableArray<int> immutableArray = ImmutableArray.Create(1, 2, 3); Console.WriteLine(immutableArray[1]); // Vrátí prvek na indexu 1: 2 Note ImmutableArray je pole, které nelze měnit. ImmutableList Seznam, který nelze měnit. Příklad: ImmutableList<int> immutableList = ImmutableList.Create(1, 2, 3); Console.WriteLine(immutableList[1]); // Vrátí prvek na indexu 1: 2 Note ImmutableList je seznam, který nelze měnit. ImmutableDictionary Kolekce klíč-hodnota, která nelze měnit. Příklad: ImmutableDictionary<string, int> immutableDictionary = ImmutableDictionary.Create<string, int>(); immutableDictionary = immutableDictionary.Add(\"key1\", 1); // Add() přidá klíč a hodnotu do tabulky immutableDictionary = immutableDictionary.Add(\"key2\", 2); immutableDictionary = immutableDictionary.Add(\"key3\", 3); Console.WriteLine(immutableDictionary[\"key2\"]); // Vrátí hodnotu pod klíčem \"key2\": 2 immutableDictionary = immutableDictionary.Remove(\"key2\"); // Remove() odebere klíč a hodnotu z tabulky Console.WriteLine(immutableDictionary.ContainsKey(\"key2\")); // false Note ImmutableDictionary je kolekce klíč-hodnota, která nelze měnit. Immutable HashSet Množina prvků, kterou nelze měnit. Příklad: ImmutableHashSet<int> immutableHashSet = ImmutableHashSet.Create(1, 2, 3); Console.WriteLine(immutableHashSet.Contains(2)); // Contains() zjistí, zda množina obsahuje prvek: true Note ImmutableHashSet je množina prvků, kterou nelze měnit. Immutable SortedSet Seřazená množina prvků, kterou nelze měnit. Příklad: ImmutableSortedSet<int> immutableSortedSet = ImmutableSortedSet.Create(3, 1, 2); Console.WriteLine(immutableSortedSet.Min); // Min vrátí nejmenší prvek: 1 Note ImmutableSortedSet je seřazená množina prvků, kterou nelze měnit. Immutable Queue Fronta prvků, kterou nelze měnit. Příklad: ImmutableQueue<int> immutableQueue = ImmutableQueue.Create(1, 2, 3); Console.WriteLine(immutableQueue.Peek()); // Peek() vrátí první prvek: 1 Note ImmutableStack je zásobník prvků, který nelze měnit. ImmutableStack Zásobník prvků, který nelze měnit. Příklad: ImmutableStack<int> immutableStack = ImmutableStack.Create(1, 2, 3); Console.WriteLine(immutableStack.Peek()); // Peek() vrátí poslední prvek: 3 Note ImmutableQueue je fronta prvků, kterou nelze měnit. Paměťové kolekce Umožňují bezpečný přístup k paměti a manipulaci s ní Memory Ukazatel na paměť, který umožňuje bezpečný přístup k paměti. Příklad: Memory<int> memory = new Memory<int>(new int[] { 1, 2, 3 }); Console.WriteLine(memory.Span[1]); // Span[] vrátí prvek na indexu 1: 2 Note Memory je užitečná pro bezpečný přístup k paměti. Span Ukazatel na paměť, který umožňuje bezpečný přístup k paměti. Příklad: Span<int> span = new Span<int>(new int[] { 1, 2, 3 }); Console.WriteLine(span[1]); // Vrátí prvek na indexu 1: 2 Note Span je užitečná pro bezpečný přístup k paměti. Slabé reference Umožňují udržovat odkazy na objekty bez zabránění jejich uvolnění garbage collectorem WeakReference Slabá reference na objekt, která nezabraňuje garbage collectoru v uvolnění paměti. Příklad: WeakReference<int> weakReference = new WeakReference<int>(1); Console.WriteLine(weakReference.TryGetTarget(out int value)); // TryGetTarget() vrátí hodnotu: true Note WeakReference je užitečná pro sledování objektů, které mohou být uvolněny garbage collectorem. Kolekce pro více vláken Jsou bezpečné pro použití ve více vláknech, což zajišťuje synchronizaci a bezpečnost dat ConcurrentQueue Fronta, která je bezpečná pro použití ve více vláknech. Příklad: ConcurrentQueue<int> concurrentQueue = new ConcurrentQueue<int>(); concurrentQueue.Enqueue(1); // Enqueue() vloží prvek do fronty concurrentQueue.Enqueue(2); concurrentQueue.Enqueue(3); Console.WriteLine(concurrentQueue.TryDequeue(out int value)); // TryDequeue() vyjme první prvek z fronty: true Console.WriteLine(value); // 1 Note ConcurrentQueue je bezpečná pro použití ve více vláknech. ConcurrentStack Zásobník, který je bezpečný pro použití ve více vláknech. Příklad: ConcurrentStack<int> concurrentStack = new ConcurrentStack<int>(); concurrentStack.Push(1); // Push() vloží prvek na zásobník concurrentStack.Push(2); concurrentStack.Push(3); Console.WriteLine(concurrentStack.TryPop(out int value)); // TryPop() vyjme poslední prvek ze zásobníku: true Console.WriteLine(value); // 3 Note ConcurrentStack je bezpečný pro použití ve více vláknech. ConcurrentDictionary Kolekce klíč-hodnota, která je bezpečná pro použití ve více vláknech. Příklad: ConcurrentDictionary<string, int> concurrentDictionary = new ConcurrentDictionary<string, int>(); concurrentDictionary.TryAdd(\"key1\", 1); // TryAdd() přidá klíč a hodnotu do tabulky concurrentDictionary.TryAdd(\"key2\", 2); concurrentDictionary.TryAdd(\"key3\", 3); Console.WriteLine(concurrentDictionary[\"key2\"]); // Vrátí hodnotu pod klíčem \"key2\": 2 concurrentDictionary.TryRemove(\"key2\", out _); // TryRemove() odebere klíč a hodnotu z tabulky Console.WriteLine(concurrentDictionary.ContainsKey(\"key2\")); // false Note ConcurrentDictionary je bezpečná pro použití ve více vláknech. ConcurrentBag Kolekce prvků, která je bezpečná pro použití ve více vláknech. Příklad: ConcurrentBag<int> concurrentBag = new ConcurrentBag<int>(); concurrentBag.Add(1); // Add() přidá prvek do kolekce concurrentBag.Add(2); concurrentBag.Add(3); Console.WriteLine(concurrentBag.TryTake(out int value)); // TryTake() vyjme prvek z kolekce: true Console.WriteLine(value); // 1 Note ConcurrentBag je bezpečná pro použití ve více vláknech. BlockingCollection Kolekce prvků, která blokuje vlákno, pokud je prázdná nebo plná. Příklad: BlockingCollection<int> blockingCollection = new BlockingCollection<int>(); Task.Run(() => { blockingCollection.Add(1); // Add() přidá prvek do kolekce }); Console.WriteLine(blockingCollection.Take()); // Take() vyjme prvek z kolekce Note BlockingCollection je užitečná pro synchronizaci mezi vlákny."
  },
  "programming/net/net_enum.html": {
    "href": "programming/net/net_enum.html",
    "title": "| Vývojář",
    "summary": "Enum = enum je výčtový typ, který umožňuje definovat vlastní datový typ, který může nabývat jedné z předem definovaných hodnot. Typy enum A {}: Velký batoh, který může držet hodně věcí (čísel). Zabírá 4 bajty místa. enum A : byte {}: Malý batoh, který může držet jen pár věcí (čísel od 0 do 255). Zabírá jen 1 bajt místa. Tip Pokud potřebujete ušetřit místo a máte jen pár čísel, můžete použít byte. Pokud však potřebujete hodně čísel nebo negativní čísla, budete muset použít int."
  },
  "programming/net/net_files.html": {
    "href": "programming/net/net_files.html",
    "title": "| Vývojář",
    "summary": "Vyhledat oddělovač public static StreamReader FindDelimiter(StreamReader reader, out char delimiter, int? linesToRead = null) { const char semicolon = ';'; const char comma = ','; Dictionary<char, int> delimiters = new Dictionary<char, int> { { semicolon, default(int) }, { comma, default(int) }, }; string line; int linesRead = 0; while ((line = reader.ReadLine()) != null && (!linesToRead.HasValue || linesRead < linesToRead.Value)) { foreach (char c in line) { switch (c) { case semicolon: delimiters[semicolon]++; break; case comma: delimiters[comma]++; break; } } linesRead++; } delimiters = delimiters.Where(i => i.Value != 0).ToDictionary(i => i.Key, i => i.Value); if (delimiters.Count == 0) throw new Exception(\"Nepodařilo se dohledat jakýkoli oddělovač.\"); var highest = delimiters.Aggregate((item1, item2) => item1.Value > item2.Value ? item1 : item2); // Kontrola, zda existuje jiný oddělovač, který se vyskytuje alespoň v 70% případů jako nejčastější oddělovač const int failPercentage = 70; if ((from val in delimiters where val.Key != highest.Key select new decimal(val.Value) / new decimal(highest.Value) * 100).Any(diff => diff >= failPercentage)) throw new Exception(\"Typ oddělovače se nepodařilo jednoznačne identifikovat.\"); delimiter = highest.Key; reader.DiscardBufferedData(); reader.BaseStream.Seek(0, System.IO.SeekOrigin.Begin); return reader; } Escape sekvence \\uFEFF = Byte Order Mark (BOM). BOM nám říká, jak číst data v souboru - od začátku nebo od konce. Warning Může způsobit problémy s některými nástroji a knihovnami, které jej neočekávají. \\u0000 = null znak. Null znak je speciální znak, který se často používá k označení konce řetězce v některých programovacích jazycích a systémech. Warning Je obvykle nepotřebný a může způsobit problémy při parsování nebo zpracování dat."
  },
  "programming/net/net_interface.html": {
    "href": "programming/net/net_interface.html",
    "title": "| Vývojář",
    "summary": "Interface = rozhraní ICloneable Vytvoří kopii objektu Mělká public object Clone () { // Pro referenční typy se kopíruje reference (odkaz), nikoli objekt return this.MemberwiseClone(); } Hluboká Kopírování referencí jako objekt Warning Může mít vliv na výkon Automaticky: public static T DeepClone<T>(T obj) { using (var ms = new MemoryStream()) { var formatter = new BinaryFormatter(); formatter.Serialize(ms, obj); ms.Position = 0; return (T) formatter.Deserialize(ms); } } Ručně: public class Record : ICloneable { // ... other properties ... public List<string> Tnr { get; set; } public List<string> Ean { get; set; } // ... other properties ... public object Clone() { return new Record { // ... clone other properties ... Tnr = this.Tnr != null ? new List<string>(this.Tnr) : null, Ean = this.Ean != null ? new List<string>(this.Ean) : null, // ... clone other properties ... }; } } [!NOTE] Stejným způsob pro klonování vnořených objektů"
  },
  "programming/net/net_methods.html": {
    "href": "programming/net/net_methods.html",
    "title": "| Vývojář",
    "summary": "Základní pojmy Parametr proměnná v definici metody Argument skutečná hodnota této proměnné, která je předána při volání metody. Předání reference či hodnoty do metody **`Value`** Pokud předáváte data hodnotou, **vytvoří se kopie dat** a ta se předá do metody. > [!WARNING] > Jakákoli změna dat v metodě **neovlivní původní data**. > > Pro velké struktury nebo třídy může být kopírování dat náročné na paměť a čas. > [!NOTE] > **Efektivní pro malé datové typy** > > Jako jsou `int`, `float`, `bool` atd... > > Kopírování těchto malých hodnot je rychlé. **`Reference`** Pokud předáte data odkazem pomocí klíčových slov `ref`, `out` nebo `in`, místo kopírování dat se **předá odkaz na původní data**. > [!WARNING] > Metoda může přímo **manipulovat s původními daty**. > > **Neplatí pouze pro klíčové slovo `in`**, jelikož ta umožňuje pouze čtení dat. > [!NOTE] > **Efektivní pro velké struktury nebo třídy**, protože se vyhnete nákladnému kopírování dat. > > Předá se jen malý odkaz na data. Druhy metod Indexátor Speciální druh členské funkce v C#, která umožňuje objektům být indexovány jako pole. Příklad použití: Definice /// <summary> OAuth2 library configuration. </summary> public interface IOAuth2Configuration { /// <summary> Returns settings for service client with given name. </summary> IClientConfiguration this[string clientTypeName] { get; } } Volání IOAuth2Configuration config = ... IClientConfiguration clientConfig = config[\"clientTypeName\"]; Note Není zapotřebí vytvářet tedy novou funkci jako například: GetClientConfiguration(string clientTypeName). Statické metody Deklarovány s klíčovým slovem static. Note Mohou být volány bez vytváření instance třídy. public static void MyStaticMethod() { // kód metody } Instanční metody Warning Vyžaduje vytvořenou instanci třídy pro jejich volání. Instance třídy = Objekt vytvořený z dané třídy. public void MyInstanceMethod() { // kód metody } Virtuální metody Deklarovány s klíčovým slovem virtual Umožňuje potomkům třídy přepsat jejich implementaci. public virtual void MyVirtualMethod() { // kód metody } Abstraktní metody Deklarovány s klíčovým slovem abstract Warning Nemají žádnou vlastní implementaci. Implementaci musí poskytnout třída, která dědí z abstraktní třídy. public abstract void MyAbstractMethod(); Přetížené metody Metody se stejným názvem, které se liší v počtu nebo typu parametrů. public void MyMethod(int param1) { // kód metody } public void MyMethod(int param1, int param2) { // kód metody } Metody s výchozími hodnotami Jedná se o parametry, které mohou být při volání metody vynechány. Warning Parametry s výchozími hodnotami lze použít až po všech nevýchozích parametrech. Neplatí pro parametr s klíčovým slovem params, ten musí být vždy poslední v seznamu parametrů. public void MyMethod(int param1, int param2 = 10) { // kód metody } Note Při volání této metody by mohl být vynechán param2. Pokud by tento parametr byl vynechán, použila by se jeho výchozí hodnota tedy = 10. Metody s parametry params Mohou přijímat libovolný počet parametrů stejného typu. Warning Musí být vždy poslední v seznamu parametrů. public void MyMethod(params int[] numbers) { // kód metody } Metody s výstupními (out) a referenčními (ref) parametry Mohou měnit hodnotu argumentů předaných do metody. public void MyMethod(out int param1, ref int param2) { // kód metody } ref Klíčové slovo ref se používá k označení parametru, který se má předat odkazem. Note Pokud metoda změní hodnotu ref parametru, změna se projeví i na původní proměnné, která byla předána do metody. Warning Musí být inicializovány před jejich předáním do metody. Příklad: public void AddTen(ref int number) { number += 10; } int myNumber = 5; AddTen(ref myNumber); // myNumber je nyní 15 out Klíčové slovo out se používá k označení parametru, který se má předat odkazem a bude použit k vrácení dat z metody. Warning Musí být nastaveny v rámci metody před jejím ukončením. Note Užitečné v situacích, kdy chcete, aby metoda vrátila více než jednu hodnotu. Nemusí být inicializovány před jejich předáním do metody. Příklad: public void GetValues(out int x, out int y) { x = 5; y = 10; } int a, b; GetValues(out a, out b); // a je nyní 5, b je nyní 10 in Klíčové slovo in se používá k označení parametru, který se má předat odkazem, ale nemůže být změněn metodou. Note Užitečné pro předání velkých struktur nebo tříd, protože se předávají odkazem (efektivněji) a bez rizika, že by metoda změnila jejich hodnotu. Příklad: public void PrintValue(in int number) { Console.WriteLine(number); // number = 10; // Toto by způsobilo chybu kompilace } int myNumber = 5; PrintValue(in myNumber); // Vypíše 5 Rozšířené metody Rozšiřují existující typy o nové metody bez nutnosti dědění nebo změny původního typu. public static class MyExtensionMethods { public static void MyExtensionMethod(this MyType myType) { // kód metody } } Asynchronní metody Deklarovány s klíčovým slovem async. Umožňují asynchronní operace. Note Asynchronní operace Běží nezávisle na hlavním programu. Umožňuje tedy hlavnímu programu pokračovat v práci, aniž by musel čekat na dokončení operace. public async Task MyAsyncMethod() { // kód metody } Je sepsána samostatná sekce, kde se lze dozvědět více. Ukazetel na metody Delegáti Drží odkazy na metody. Když je delegát volán, volá se metoda, na kterou odkazuje. Note Typově bezpečný. Bezpečně tedy zapouzdřují metodu nebo sadu metod. Užitečné pro implementaci událostí a zpětných volání. Jsou základem pro LINQ dotazy a asynchronní metody. Příklad: // Definice delegáta public delegate void MyDelegate(string message); // Metoda, která odpovídá signatuře delegáta public void MyMethod(string message) { Console.WriteLine(message); } // Použití delegáta MyDelegate del = MyMethod; del(\"Hello, World!\"); // Vypíše \"Hello, World!\" na konzoli Delegáti - Generické Warning Je zapotřebí znalost základních delegátů Func Delegát pro metody, který vrací hodnotu. Func<TResult> Představuje metodu, která vrací hodnotu typu TResult. Func<T, TResult> Představuje metodu, která přijímá jeden argument typu T a vrací hodnotu typu TResult. Note Func<T1,T2,T3...TResult> umožňuje až 16 vstupních parametrů. Příklad: // Using Func delegate Func<Player, int, int> Attack = (p, damage) => { p.Health -= damage; Console.WriteLine($\"{p.Name} is attacked and lost {damage} health.\"); return p.Health; }; int remainingHealth = Attack(player, 20); Action Delegát, který nevrací hodnotu. Action Představuje metodu bez parametrů. Action<T> Představuje metodu, která přijímá jeden argument typu T. Note Action<T1,T2,T3...> umožňuje až 16 vstupních parametrů. Příklad: Action<string> actionMethod = message => Console.WriteLine(message); // Použití delegáta k zobrazení zprávy actionMethod(\"Hello, World!\"); Predicate Reprezentuje metodu, která přijímá jeden argument typu T a vrací bool. Note Je to speciální případ Func<T, bool>. Příklad: Predicate<int> isEven = x => x % 2 == 0; bool result = isEven(4); // result je true Asynchronní a Paralelní metody Umožňuje vykonávání operací bez blokování (nebo \"zamrzání\") hlavního vlákna aplikace. Note Kód může pokračovat v dalších úlohách, zatímco asynchronní operace běží \"na pozadí\". Mohou být přerušeny, aby uvolnily vlákno pro jiné úkoly. Tip Klíčové slova async pro označení metod jako asynchronních a await pro čekání na dokončení asynchronních operací nebo úloh. Příklady použití I/O operace: Čtení/zápis souborů, síťové požadavky, přístup k databázi. Časově náročné výpočty: Operace, které trvají dlouho a mohou být prováděny na pozadí. Čekání na události: Čekání na uživatelský vstup nebo jiné události. Vytvoření metody Bez návratové hodnoty public async Task MyAsyncMethod() { // Zde můžete provést nějakou synchronní práci int x = 10; int y = 20; int sum = x + y; // Použijte Task.CompletedTask k naplnění smlouvy asynchronní metody await Task.CompletedTask; } S návratovou hodnotou public async Task<int> MyAsyncMethod() { // Zde můžete provést nějakou synchronní práci int x = 10; int y = 20; int sum = x + y; // Použijte Task.FromResult k naplnění smlouvy asynchronní metody return await Task.FromResult(sum); } Volání v asynchronní metodě public async Task MethodA() { // Nějaký kód... // Volání MethodB z MethodA await MethodB(); // Další kód... } public async Task MethodB() { // Nějaký kód... // Simulace asynchronní operace await Task.Delay(1000); // Další kód... } Volání v synchronní metodě Warning Nedoporučuje se používat asynchronní metody v synchronní metodě pokud je to možné. Zpracovat výsledek v novém vlákně public void MySyncMethod() { // Zde můžete provést nějakou synchronní práci int x = 10; int y = 20; int sum = x + y; // Volání asynchronní metody ve vlákně ThreadPool Task task = Task.Run(async () => await MyAsyncMethod()); // Počkejte na dokončení úkolu task.Wait(); } private void OnEnable() { // Spuštění asynchronní operace Task<T> task = MyAsyncMethod(); // Zpracování výsledku po dokončení úlohy (také se spustí asynchronně) task.ContinueWith(t => { if (t.IsFaulted) { // Zpracování všech výjimek Debug.LogError(t.Exception); } else { // Použijte výsledek T result = t.Result; // ... } }); } Tip Metoda ContinueWith je použita pro plánování další operace, která se má vykonat po dokončení úlohy. Pokud metoda narazí na ContinueWith, vytvoří se nový úkol, který se spustí po dokončení původní úlohy. Obvykle se spustí na jiném vlákně, než je hlavní vlákno. (To je dáno tím, jak .NET spravuje svůj thread pool.) Zpracovat výsledek v hlavním vlákně Warning Nedoporučuje se. Může to vést k problémům s výkonem a odezvou aplikace. Tip Hlavní vlákno je obvykle vlákno, které zpracovává události uživatelského rozhraní (UI) a další kritické operace. Pokud hlavní vlákno zablokujete čekáním na dokončení asynchronní operace, může to způsobit, že se vaše aplikace \" zasekne\" nebo přestane reagovat na vstupy uživatele. private void OnEnable() { // Spuštění asynchronní operace Task<T> task = MyAsyncMethod(); // Tím se zablokuje aktuální vlákno, dokud nebude asynchronní operace dokončena. T result = task.GetAwaiter().GetResult(); } Task Parallel Library (TPL) TPL je sada API, které umožňují paralelní programování. Tip TPL zahrnuje Task a Task<T> třídy, které reprezentují jednotlivé operace, které mohou být asynchronní a mohou vrátit hodnotu. TPL také zahrnuje Parallel třídu pro paralelní iterace a regiony. Typy metod k použití: asynchronní a paralelní Vytváření a spouštění úloh Task task = Task.Run(async () => { // Kód úlohy await SomeAsyncMethod(); }); Čekání na dokončení úlohy Task task = Task.Run(async () => { // Kód úlohy await SomeAsyncMethod(); }); await task; Získání výsledku úlohy Task<int> task = Task.Run(async () => { // Kód úlohy return await SomeAsyncMethodReturningInt(); }); int result = await task; Řetězení úloh Task<int> task = Task.Run(async () => { // Kód první úlohy return await SomeAsyncMethodReturningInt(); }).ContinueWith(async previousTask => { // Kód druhé úlohy return await SomeOtherAsyncMethod(previousTask.Result); }); int result = await task; Paralelní cykly var items = Enumerable.Range(0, 10); var tasks = items.Select(async i => { // Kód pro každou iteraci await SomeAsyncMethod(i); }); await Task.WhenAll(tasks); Paralelní zpracování kolekcí var items = new List<int> { 1, 2, 3, 4, 5 }; var tasks = items.Select(async item => { // Kód pro každou položku await SomeAsyncMethod(item); }); await Task.WhenAll(tasks); Paralelní spuštění více operací var tasks = new[] { Task.Run(async () => { await SomeAsyncMethod(); }), Task.Run(async () => { await SomeOtherAsyncMethod(); }), Task.Run(async () => { await YetAnotherAsyncMethod(); }) }; await Task.WhenAll(tasks); Asynchronní metody s async a await public async Task DoWorkAsync() { await Task.Run(async () => { // Kód úlohy await SomeAsyncMethod(); }); } Synchronní a paralelní Vytváření a spouštění úloh Task task = Task.Run(() => { // Kód úlohy }); Čekání na dokončení úlohy Task task = Task.Run(() => { // Kód úlohy }); task.Wait(); Získání výsledku úlohy Task<int> task = Task.Run(() => { // Kód úlohy return 42; }); int result = task.Result; Řetězení úloh Task<int> task = Task.Run(() => { // Kód první úlohy return 42; }).ContinueWith(previousTask => { // Kód druhé úlohy return previousTask.Result * 2; }); int result = task.Result; Paralelní cykly Parallel.For(0, 10, i => { // Kód pro každou iteraci }); Paralelní zpracování kolekcí var items = new List<int> { 1, 2, 3, 4, 5 }; Parallel.ForEach(items, item => { // Kód pro každou položku }); Paralelní spuštění více operací Parallel.Invoke( () => { /* Kód první operace */ }, () => { /* Kód druhé operace */ }, () => { /* Kód třetí operace */ } ); Příklady Spustit v asynchronním módu using System.Threading.Tasks; public class TPLExample { public async Task RunTasksAsync() { // Vytvoření a spuštění úloh paralelně Task task1 = DoWorkAsync(1); Task task2 = DoWorkAsync(2); Task task3 = DoWorkAsync(3); // Čekání na dokončení všech úloh await Task.WhenAll(task1, task2, task3); } private async Task DoWorkAsync(int taskNumber) { // Simulace nějaké práce for (int i = 0; i < 10; i++) { System.Console.WriteLine($\"Úloha {taskNumber}: iterace {i}\"); await Task.Delay(1000); // Pauza 1 sekunda } } } Spustit v synchronním módu using System.Threading.Tasks; public class TPLExample { public void RunTasks() { // Vytvoření a spuštění úloh paralelně Task task1 = Task.Run(() => DoWork(1)); Task task2 = Task.Run(() => DoWork(2)); Task task3 = Task.Run(() => DoWork(3)); // Čekání na dokončení všech úloh Task.WaitAll(task1, task2, task3); } private void DoWork(int taskNumber) { // Simulace nějaké práce for (int i = 0; i < 10; i++) { System.Console.WriteLine($\"Úloha {taskNumber}: iterace {i}\"); System.Threading.Thread.Sleep(1000); // Pauza 1 sekunda } } } Zjištění kde se kód vykonává Thread.CurrentThread k získání odkazu na aktuální vlákno. Poté lze zkontrolovat jeho vlastnosti, jako je IsThreadPoolThread nebo IsBackground, které mohou poskytnout další informace. Tipy Vytvořit vlastní LINQ Lze toho dosáhnout skrze rozšíření metod a delegátů. Příklad: public static class MyExtensions { public static IEnumerable<T> MyWhere<T>(this IEnumerable<T> collection, Func<T, bool> predicate) { foreach (var item in collection) { if (predicate(item)) { yield return item; } } } } V tomto příkladu MyWhere je rozšíření metody pro IEnumerable<T>, což znamená, že ji můžete použít na jakoukoli kolekci. Metoda přijímá delegáta Func<T, bool>, který je použit k rozhodnutí, zda prvek splňuje danou podmínku. Můžete pak použít tuto metodu podobně jako metodu where v LINQ: List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; var evenNumbers = numbers.MyWhere(x => x % 2 == 0); // filtruje sudá čísla v seznamu. Synchronizace vláken pomocí lock Zabrání vstupu jiného vlákna do bloku kódu. Note Zajistí tedy, že blok kódu uvnitř lock může být v daném okamžiku spuštěn pouze jedním vláknem. Příklad: object zamek = new object(); lock (zamek) { // Kód, který má být prováděn pouze jedním vláknem } Note Když vlákno vstoupí do bloku lock, získá zámek na objektu zamek. Jakmile vlákno opustí lock, zamek je automaticky uvolněn. Warning Použití lock(this) je nebezpečné, protože jiné části kódu mohou také získat zámek na this a způsobit deadlock."
  },
  "programming/net/net_nunit.html": {
    "href": "programming/net/net_nunit.html",
    "title": "| Vývojář",
    "summary": "NUnit = Testovací framework Multiple Asserts Nechceme, aby se test ukončil, jakmile první assert selže uvnitř metody. Ve standardním případě, pokud první test selže, tak následující testy již nejsou spuštěny z této metody. Note Stane se pouze v případě, že máme více assert v jedné metodě. Příklad použití: [Test] public void MultipleAssertsDemo() { var situationUnderTest = new SomeCalculator(); var result = situationUnderTest.DoCalculation(); Assert.Multiple(() => { Assert.That(result.RealPart, Is.EqualTo(5.2)); Assert.That(result.ImaginaryPart, Is.EqualTo(3.9)); }); // Can also work with the classic assertion syntax Assert.Multiple(() => { ClassicAssert.AreEqual(5.2, result.RealPart, \"Real Part\"); ClassicAssert.AreEqual(3.9, result.ImaginaryPart, \"Imaginary Part\"); }); } Video prezentace Trendy v unit testování a mockování (WUG Days 2018)"
  },
  "programming/net/net_wpf.html": {
    "href": "programming/net/net_wpf.html",
    "title": "| Vývojář",
    "summary": "WPF (Windows Presentation Foundation) Tvorba desktopových aplikací na platformě Windows Odděluje logiku aplikace (C#) od vzhledu (XAML) Umožňuje datové vazby a stylování Podpora vektorové grafiky, animací a multimédií Prvky Button Tlačítko je interaktivní prvek, na který může uživatel kliknout. Vlastnosti, které lze stylovat Background: Barva pozadí tlačítka. Foreground: Barva textu. BorderBrush: Barva ohraničení. BorderThickness: Tloušťka ohraničení. FontSize: Velikost písma. Padding: Vnitřní odsazení (rozestup textu od okrajů). Margin: Vnější odsazení (rozestup tlačítka od ostatních prvků). CornerRadius: Zaoblení rohů tlačítka. Události Click: Vyvolána, když uživatel klikne na tlačítko. Příklad použití <Button Content=\"Klikni na mě\" Background=\"LightBlue\" Foreground=\"White\" BorderBrush=\"Blue\" BorderThickness=\"2\" FontSize=\"16\" Padding=\"10\" Margin=\"10\" CornerRadius=\"5\"/> TextBox TextBox je prvek pro vstup textu od uživatele. Vlastnosti, které lze stylovat Background: Barva pozadí vstupního pole. Foreground: Barva textu. BorderBrush: Barva ohraničení. BorderThickness: Tloušťka ohraničení. FontSize: Velikost písma. Padding: Vnitřní odsazení. Margin: Vnější odsazení. Width: Šířka pole. Height: Výška pole. Události TextChanged: Vyvolána, když se změní obsah TextBox. GotFocus: Vyvolána, když TextBox získá fokus. LostFocus: Vyvolána, když TextBox ztratí fokus. Příklad použití <TextBox Text=\"Zadejte text\" Background=\"White\" Foreground=\"Black\" BorderBrush=\"Gray\" BorderThickness=\"1\" FontSize=\"14\" Padding=\"5\" Margin=\"10\" Width=\"200\" Height=\"30\" TextChanged=\"TextBox_TextChanged\" GotFocus=\"TextBox_GotFocus\" LostFocus=\"TextBox_LostFocus\"/> CheckBox CheckBox je prvek, který umožňuje uživateli vybrat nebo odznačit volbu. Vlastnosti, které lze stylovat Background: Barva pozadí. Foreground: Barva textu. BorderBrush: Barva ohraničení. BorderThickness: Tloušťka ohraničení. FontSize: Velikost písma. Padding: Vnitřní odsazení. Margin: Vnější odsazení. Události Checked: Vyvolána, když uživatel zaškrtne CheckBox. Unchecked: Vyvolána, když uživatel odškrtne CheckBox. Click: Vyvolána, když uživatel klikne na CheckBox. Příklad použití <CheckBox Content=\"Souhlasím s podmínkami\" Background=\"Transparent\" Foreground=\"Black\" BorderBrush=\"Gray\" BorderThickness=\"1\" FontSize=\"14\" Padding=\"5\" Margin=\"10\" Checked=\"CheckBox_Checked\" Unchecked=\"CheckBox_Unchecked\" Click=\"CheckBox_Click\"/> ComboBox ComboBox je prvek, který umožňuje výběr jedné hodnoty z rozevíracího seznamu. Vlastnosti, které lze stylovat Background: Barva pozadí. Foreground: Barva textu. BorderBrush: Barva ohraničení. BorderThickness: Tloušťka ohraničení. FontSize: Velikost písma. Padding: Vnitřní odsazení. Margin: Vnější odsazení. Width: Šířka pole. Height: Výška pole. Události SelectionChanged:Vyvolána, když uživatel vybere novou položku v ComboBox. DropDownOpened: Vyvolána, když je rozevírací seznam otevřen. DropDownClosed: Vyvolána, když je rozevírací seznam zavřen. Příklad použití <ComboBox Background=\"White\" Foreground=\"Black\" BorderBrush=\"Gray\" BorderThickness=\"1\" FontSize=\"14\" Padding=\"5\" Margin=\"10\" Width=\"150\" Height=\"30\" SelectionChanged=\"ComboBox_SelectionChanged\" DropDownOpened=\"ComboBox_DropDownOpened\" DropDownClosed=\"ComboBox_DropDownClosed\"> <ComboBoxItem Content=\"Možnost 1\"/> <ComboBoxItem Content=\"Možnost 2\"/> <ComboBoxItem Content=\"Možnost 3\"/> </ComboBox> RadioButton RadioButton je prvek, který umožňuje uživateli vybrat jednu možnost z více možností. Vlastnosti, které lze stylovat Background: Barva pozadí. Foreground: Barva textu. BorderBrush: Barva ohraničení. BorderThickness: Tloušťka ohraničení. FontSize: Velikost písma. Padding: Vnitřní odsazení. Margin: Vnější odsazení. Události Checked: Vyvolána, když je RadioButton vybrán. Unchecked: Vyvolána, když je RadioButton odznačen. Click: Vyvolána, když uživatel klikne na RadioButton. Příklad použití <StackPanel Margin=\"10\"> <TextBlock Text=\"Vyberte si jednu z možností:\" FontSize=\"16\" Margin=\"0,0,0,10\"/> <RadioButton Content=\"Možnost A\" GroupName=\"OptionsGroup\" Background=\"LightGray\" Foreground=\"Black\" BorderBrush=\"DarkGray\" BorderThickness=\"2\" FontSize=\"14\" Padding=\"8\" Margin=\"0,5\" CornerRadius=\"10\" Checked=\"RadioButton_Checked\" Unchecked=\"RadioButton_Unchecked\" Click=\"RadioButton_Click\"/> <RadioButton Content=\"Možnost B\" GroupName=\"OptionsGroup\" Background=\"LightGray\" Foreground=\"Black\" BorderBrush=\"DarkGray\" BorderThickness=\"2\" FontSize=\"14\" Padding=\"8\" Margin=\"0,5\" CornerRadius=\"10\" Checked=\"RadioButton_Checked\" Unchecked=\"RadioButton_Unchecked\" Click=\"RadioButton_Click\"/> </StackPanel> Slider Slider je prvek, který umožňuje uživateli vybrat hodnotu posunutím jezdce. Vlastnosti, které lze stylovat Background: Barva pozadí. Foreground: Barva jezdce. BorderBrush: Barva ohraničení. BorderThickness: Tloušťka ohraničení. Width: Šířka slideru. Height: Výška slideru. Události ValueChanged: Vyvolána, když se změní hodnota Slider. GotFocus: Vyvolána, když Slider získá fokus. LostFocus: Vyvolána, když Slider ztratí fokus. Příklad použití <Slider Minimum=\"0\" Maximum=\"100\" Value=\"50\" Background=\"LightGray\" Foreground=\"Blue\" Width=\"200\" Height=\"30\" Margin=\"10\" ValueChanged=\"Slider_ValueChanged\" GotFocus=\"Slider_GotFocus\" LostFocus=\"Slider_LostFocus\"/> Vlastní ovládací prvek Pokud standardní ovládací prvky nevyhovují vašim potřebám, můžete vytvořit vlastní ovládací prvek. Definice vlastního ovládacího prvku Vytvořte třídu vlastního ovládacího prvku. (Tato třída by měla dědit z existujícího ovládacího prvku, např. Button.) using System.Windows; using System.Windows.Controls; namespace YourNamespace { public class MyCustomButton : Button { static MyCustomButton() { DefaultStyleKeyProperty.OverrideMetadata(typeof(MyCustomButton), new FrameworkPropertyMetadata(typeof(MyCustomButton))); } } } DefaultStyleKeyProperty: Určuje výchozí styl pro vlastní ovládací prvek. Definujte styl a šablonu pro vlastní ovládací prvek Styl a šablonu můžete definovat v XAML jako obvykle. <Window.Resources> <Style TargetType=\"{x:Type local:MyCustomButton}\"> <Setter Property=\"Background\" Value=\"LightGray\"/> <Setter Property=\"Foreground\" Value=\"Black\"/> <Setter Property=\"FontSize\" Value=\"16\"/> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"{x:Type local:MyCustomButton}\"> <Border Background=\"{TemplateBinding Background}\" BorderBrush=\"Black\" BorderThickness=\"2\" CornerRadius=\"10\"> <ContentPresenter HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\"/> </Border> </ControlTemplate> </Setter.Value> </Setter> </Style> </Window.Resources> Použití vlastního ovládacího prvku v XAML: <local:MyCustomButton Content=\"Moje vlastní tlačítko\" Width=\"200\" Height=\"50\"/> Styly Styl se používá k definování vzhledu a chování více prvků najednou. Definuje se pomocí XAML. Definování stylu Styl se definuje v sekci Resources: <Window.Resources> <Style x:Key=\"MyButtonStyle\" TargetType=\"Button\"> <Setter Property=\"Background\" Value=\"Blue\"/> <Setter Property=\"Foreground\" Value=\"White\"/> <Setter Property=\"FontSize\" Value=\"14\"/> <Setter Property=\"Padding\" Value=\"10\"/> </Style> </Window.Resources> x: Unikátní název stylu, který použijete později. TargetType: Typ prvku, na který se styl vztahuje. Použití stylu Chcete-li styl použít na prvek, využijete atribut Style: <Button Style=\"{StaticResource MyButtonStyle}\" Content=\"Klikni na mě\"/> Prefixy x: Vyhrazen pro XAML standardní funkce a typy. Používá se pro přístup k základním vlastnostem, jako jsou x:Class, x:Name, x:Key, atd. Příklad <Window x:Class=\"MyNamespace.MainWindow\" x:Name=\"mainWindow\" x:Key=\"myWindowKey\"> xmlns: Používá se k deklaraci namespace. Obvykle se používá v kořenovém prvku XAML souboru. Příklad deklarace namespace: <Window xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:local=\"clr-namespace:MyNamespace\"> local: Používán k odkazování na vlastní namespace aplikace. Můžete ho použít k přístupu k vlastním ovládacím prvkům, datovým modelům a dalším třídám definovaným ve vaší aplikaci. Příklad: <local:MyCustomButton Content=\"Moje vlastní tlačítko\"/> xmlns:sys: Pro přístup k základním typům .NET, jako jsou System.String, System.Int32, atd. Příklad: xmlns:sys=\"clr-namespace:System;assembly=mscorlib\" xmlns:controls: Pro přístup k ovládacím prvkům z externích knihoven, jako je například Windows Community Toolkit. Příklad: <controls:MyCustomControl/> xmlns:mc: Používá se pro Markup Compatibility. Umožňuje použití starších XAML formátů a zajišťuje zpětnou kompatibilitu. Příklad: xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:d: Používá se pro návrhové časové funkce a umožňuje definovat prvky, které se zobrazují pouze během návrhu. Příklad: xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" Použití prefixů v XAML <Window x:Class=\"MyNamespace.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:local=\"clr-namespace:MyNamespace\" xmlns:controls=\"clr-namespace:MyCustomControls;assembly=MyCustomControlsAssembly\" xmlns:sys=\"clr-namespace:System;assembly=mscorlib\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" mc:Ignorable=\"d\" Title=\"Hlavní okno\" Height=\"350\" Width=\"525\"> <Grid> <local:MyCustomButton Content=\"Moje vlastní tlačítko\" Width=\"200\" Height=\"50\"/> <Button Content=\"Tlačítko\" Width=\"100\" Height=\"30\"/> </Grid> </Window> Šablony (ControlTemplates) Šablony umožňují plně přizpůsobit vzhled ovládacího prvku. Šablona definuje strukturu a vzhled prvku. Vytvoření šablony pro tlačítko <Window.Resources> <ControlTemplate x:Key=\"MyButtonTemplate\" TargetType=\"Button\"> <Border Background=\"{TemplateBinding Background}\" BorderBrush=\"Black\" BorderThickness=\"2\" CornerRadius=\"5\"> <ContentPresenter HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\"/> </Border> </ControlTemplate> </Window.Resources> ControlTemplate: Určuje, jak bude tlačítko vypadat. TemplateBinding: Slouží k vázání vlastností stylu na vlastnosti šablony. Použití šablony <Button Template=\"{StaticResource MyButtonTemplate}\" Background=\"LightBlue\" Content=\"Stylizované tlačítko\"/> Responzivní design prvků Responzivní design znamená, že se aplikace přizpůsobí různým velikostem a rozlišením obrazovky. Layout Panely WPF nabízí různé layout panely, které vám pomohou uspořádat ovládací prvky, jako jsou tlačítka nebo textová pole. Zde jsou nejčastěji používané panely Grid Rozděluje okno na řádky a sloupce. Umožňuje flexibilní uspořádání. Příklad: <Grid> <Grid.RowDefinitions> <RowDefinition Height=\"*\" /> <RowDefinition Height=\"*\" /> </Grid.RowDefinitions> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"*\" /> <ColumnDefinition Width=\"*\" /> </Grid.ColumnDefinitions> <Button Grid.Row=\"0\" Grid.Column=\"0\" Content=\"Tlačítko 1\" /> <Button Grid.Row=\"0\" Grid.Column=\"1\" Content=\"Tlačítko 2\" /> <Button Grid.Row=\"1\" Grid.Column=\"0\" Content=\"Tlačítko 3\" /> <Button Grid.Row=\"1\" Grid.Column=\"1\" Content=\"Tlačítko 4\" /> </Grid> StackPanel Ukládá ovládací prvky buď vertikálně (jeden pod druhým), nebo horizontálně (vedle sebe). Příklad: <StackPanel Orientation=\"Vertical\"> <Button Content=\"Tlačítko 1\" /> <Button Content=\"Tlačítko 2\" /> <Button Content=\"Tlačítko 3\" /> </StackPanel> Pokud chceme prvky uspořádat horizontálně: <StackPanel Orientation=\"Horizontal\"> <Button Content=\"Tlačítko 1\" /> <Button Content=\"Tlačítko 2\" /> <Button Content=\"Tlačítko 3\" /> </StackPanel> WrapPanel Pokud je na obrazovce málo místa, ovládací prvky se \"obalí\" na další řádek/sloupec. Příklad: <WrapPanel> <Button Content=\"Tlačítko 1\" Width=\"100\" Height=\"50\" /> <Button Content=\"Tlačítko 2\" Width=\"100\" Height=\"50\" /> <Button Content=\"Tlačítko 3\" Width=\"100\" Height=\"50\" /> <Button Content=\"Tlačítko 4\" Width=\"100\" Height=\"50\" /> <Button Content=\"Tlačítko 5\" Width=\"100\" Height=\"50\" /> </WrapPanel> DockPanel Umožňuje umístit ovládací prvky na okraje okna (vlevo, vpravo, nahoře, dole) a zbývající prostor zaplní jeden prvek. Příklad: <DockPanel> <Button DockPanel.Dock=\"Top\" Content=\"Horní tlačítko\" /> <Button DockPanel.Dock=\"Bottom\" Content=\"Spodní tlačítko\" /> <Button DockPanel.Dock=\"Left\" Content=\"Levé tlačítko\" /> <Button DockPanel.Dock=\"Right\" Content=\"Pravé tlačítko\" /> <Button Content=\"Centrální tlačítko\" /> </DockPanel> Dynamické Velikosti Dynamické velikosti znamenají, že se ovládací prvky automaticky přizpůsobují velikosti okna. Místo pevně definovaných hodnot můžete použít: Procentuální hodnoty Umožňují ovládacím prvkům zabírat procento rodičovského prvku. Příklad: <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"50%\"/> <!-- 50% šířky rodičovského prvku --> <ColumnDefinition Width=\"50%\"/> <!-- 50% šířky rodičovského prvku --> </Grid.ColumnDefinitions> <TextBlock Text=\"Toto zabírá 50% šířky okna\" Background=\"LightCoral\" Grid.Column=\"0\" /> <TextBlock Text=\"Toto také zabírá 50% šířky okna\" Background=\"LightBlue\" Grid.Column=\"1\" /> </Grid> Hodnoty s `*` V Gridu můžete použít * k rozdělení zbývajícího místa. Například 2* a 1* znamená, že první sloupec zabere dvakrát více místa než druhý. Příklad: <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"2*\"/> <!-- Dva díly prostoru --> <ColumnDefinition Width=\"1*\"/> <!-- Jeden díl prostoru --> </Grid.ColumnDefinitions> <TextBlock Text=\"Toto zabírá 2/3 šířky okna\" Background=\"LightCoral\" Grid.Column=\"0\"/> <TextBlock Text=\"Toto zabírá 1/3 šířky okna\" Background=\"LightBlue\" Grid.Column=\"1\"/> </Grid> Auto Automatická velikost na základě obsahu. Příklad: <Grid> <Grid.RowDefinitions> <RowDefinition Height=\"Auto\"/> <!-- Automatická výška pro hlavičku --> <RowDefinition Height=\"*\"/> <!-- Zbytek prostoru pro další prvky --> </Grid.RowDefinitions> <TextBlock Text=\"Hlavička\" Grid.Row=\"0\" FontSize=\"24\" Background=\"LightGray\" /> <Button Content=\"Toto tlačítko zabírá zbytek prostoru\" Grid.Row=\"1\" /> </Grid> Sledování Změny Velikosti Můžete sledovat změny velikosti okna a upravit rozložení ovládacích prvků. Pomocí události SizeChanged můžete reagovat na změnu velikosti okna a provést potřebné úpravy. Příklad: private void Window_SizeChanged(object sender, SizeChangedEventArgs e) { // Získání nové šířky a výšky okna double newWidth = e.NewSize.Width; double newHeight = e.NewSize.Height; // Například upravit velikost tlačítka na základě velikosti okna if (newWidth < 600) { myButton.Width = 100; // Menší šířka tlačítka } else { myButton.Width = 200; // Větší šířka tlačítka } // Můžete také změnit další vlastnosti na základě velikosti okna } Important Nezapomeňte přidat událost do XAML: <Window x:Class=\"ResponzivniDesign.MainWindow\" SizeChanged=\"Window_SizeChanged\"> ViewBox Vše, co je uvnitř ViewBoxu, se přizpůsobí velikosti okna. (Automatické škálování obsahu.) Příklad: <ViewBox> <Grid> <TextBlock Text=\"Toto je responzivní text!\" FontSize=\"20\"/> </Grid> </ViewBox> Triggery Triggery umožňují dynamicky měnit vzhled prvku na základě určitých událostí nebo podmínek. Použití triggeru Zde je příklad stylu tlačítka, který mění barvu pozadí, když je kurzor myši nad tlačítkem: <Style TargetType=\"Button\"> <Setter Property=\"Background\" Value=\"Gray\"/> <Setter Property=\"Foreground\" Value=\"White\"/> <Style.Triggers> <Trigger Property=\"IsMouseOver\" Value=\"True\"> <Setter Property=\"Background\" Value=\"Green\"/> </Trigger> </Style.Triggers> </Style> Data Binding (Vazba Modelu na View) 1. Vytvoření ViewModel Nejprve vytvoříme ViewModel, který bude obsahovat vlastnost, kterou chceme vázat. Important Použijeme INotifyPropertyChanged, aby WPF věděl, kdy se vlastnost změnila. using System.ComponentModel; public class MyViewModel : INotifyPropertyChanged { private string _name; public string Name { get { return _name; } set { _name = value; OnPropertyChanged(nameof(Name)); } } public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged(string propertyName) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } Note MyViewModel má vlastnost Name, která implementuje INotifyPropertyChanged. To zajišťuje, že pokud se Name změní, UI se automaticky aktualizuje. 2. Vytvoření XAML pro UI Vytvoříme jednoduché uživatelské rozhraní, které umožní uživateli zadat jméno a zobrazit ho. Použijeme TextBox pro zadání a TextBlock pro zobrazení. <Window x:Class=\"WpfApp.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"Binding Example\" Height=\"200\" Width=\"300\"> <Grid> <TextBox Text=\"{Binding Name, UpdateSourceTrigger=PropertyChanged}\" Width=\"200\" Margin=\"10\"/> <TextBlock Text=\"{Binding Name}\" Margin=\"10,50,10,10\"/> </Grid> </Window> UpdateSourceTrigger Možnost Popis PropertyChanged Aktualizuje vlastnost ViewModelu při každé změně textu v TextBox. LostFocus Aktualizuje vlastnost ViewModelu pouze po ztrátě fokusu. Explicit Aktualizuje vlastnost ViewModelu pouze po zavolání UpdateSource(). Default Používá výchozí chování, které závisí na ovládacím prvku (např. LostFocus pro TextBox). Note V XAML používáme {Binding Name} pro vázání TextBox a TextBlock na vlastnost Name ve ViewModelu. UpdateSourceTrigger=PropertyChanged znamená, že binding se aktualizuje při každé změně textu v TextBox. (Vlastnost ViewModelu se aktualizuje okamžitě při každé změně textu.) Příklad: <TextBox Text=\"{Binding Name, UpdateSourceTrigger=PropertyChanged}\" Width=\"200\" Margin=\"10\"/> 3. Nastavení DataContext V MainWindow.xaml.cs nastavíme DataContext na instanci našeho ViewModelu. using System.Windows; namespace WpfApp { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); DataContext = new MyViewModel(); // Nastavujeme DataContext } } } Note V konstruktoru MainWindow nastavujeme DataContext na instanci MyViewModel. To umožňuje XAML binding k vlastnostem ViewModelu. Validace INotifyPropertyChanged + IDataErrorInfo Obvykle se používá pro vracení celkové chyby objektu. Vytvoření ViewModelu s validací public class MyViewModel : INotifyPropertyChanged, IDataErrorInfo { private string _name; // Property s validací [Required(ErrorMessage = \"Pole je povinné.\")] public string Name { get => _name; set { _name = value; OnPropertyChanged(nameof(Name)); // Oznámení o změně } } // Notifikace o změně public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged(string propertyName) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } // Implementace IDataErrorInfo public string this[string columnName] { get { var validationResults = new List<ValidationResult>(); var context = new ValidationContext(this) { MemberName = columnName }; Validator.TryValidateProperty( this.GetType().GetProperty(columnName).GetValue(this), context, validationResults ); // Vrátí první chybu, pokud existuje, jinak vrátí null return validationResults.FirstOrDefault()?.ErrorMessage; } } public string Error { get { return null; // Gets a message that describes any validation errors for the object. } } } Note Použití this[string columnName]: Tato metoda slouží k validaci konkrétní vlastnosti. Pokud se objeví chyba, vrací odpovídající chybovou zprávu. XAML pro validaci pomocí IDataErrorInfo <TextBox Text=\"{Binding Name, UpdateSourceTrigger=PropertyChanged, ValidatesOnDataErrors=True}\" /> <TextBox.Style> <Style TargetType=\"TextBox\"> <Style.Triggers> <Trigger Property=\"Validation.HasError\" Value=\"True\"> <Setter Property=\"BorderBrush\" Value=\"Red\" /> <Setter Property=\"BorderThickness\" Value=\"2\" /> </Trigger> </Style.Triggers> </Style> </TextBox.Style> INotifyPropertyChanged + INotifyDataErrorInfo Umožňuje validovat více chyb na jedné vlastnosti a spravovat chybové zprávy pro každou vlastnost asynchronně. Vytvoření ViewModelu s validací public class MyViewModel : INotifyPropertyChanged, INotifyDataErrorInfo { private string _name; private readonly Dictionary<string, List<string>> _errors = new Dictionary<string, List<string>>(); // Property s validací [Required(ErrorMessage = \"Pole je povinné.\")] [StringLength(10, ErrorMessage = \"Maximálně 10 znaků.\")] public string Name { get => _name; set { _name = value; OnPropertyChanged(nameof(Name)); // Oznámení o změně ValidateProperty(nameof(Name), value); // Spuštění validace } } // Notifikace o změně public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged(string propertyName) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } // Validace vlastnosti private void ValidateProperty(string propertyName, object value) { var context = new ValidationContext(this) { MemberName = propertyName }; var validationResults = new List<ValidationResult>(); bool isValid = Validator.TryValidateProperty(value, context, validationResults); if (!isValid) { _errors[propertyName] = validationResults.Select(vr => vr.ErrorMessage).ToList(); } else { _errors.Remove(propertyName); } OnErrorsChanged(propertyName); } // Implementace INotifyDataErrorInfo public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged; // Vrací, zda má objekt nějaké chyby public bool HasErrors => _errors.Any(); // Získá seznam chyb pro konkrétní vlastnost public IEnumerable GetErrors(string propertyName) { if (_errors.ContainsKey(propertyName)) return _errors[propertyName]; return null; } protected void OnErrorsChanged(string propertyName) { ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName)); } } XAML pro validaci pomocí INotifyDataErrorInfo <TextBox Text=\"{Binding Name, UpdateSourceTrigger=PropertyChanged, ValidatesOnNotifyDataErrors=True}\" /> <TextBox.Style> <Style TargetType=\"TextBox\"> <Style.Triggers> <Trigger Property=\"Validation.HasError\" Value=\"True\"> <Setter Property=\"BorderBrush\" Value=\"Red\" /> <Setter Property=\"BorderThickness\" Value=\"2\" /> </Trigger> </Style.Triggers> </Style> </TextBox.Style> Animace WPF podporuje animace, které umožňují měnit vlastnosti prvků v čase. Zde je příklad, jak animovat změnu barvy pozadí tlačítka, když na něj najedete: <Button Content=\"Klikni na mě\"> <Button.Triggers> <EventTrigger RoutedEvent=\"Button.MouseEnter\"> <BeginStoryboard> <Storyboard> <ColorAnimation Storyboard.TargetProperty=\"(Button.Background).(SolidColorBrush.Color)\" To=\"Red\" Duration=\"0:0:1\"/> </Storyboard> </BeginStoryboard> </EventTrigger> </Button.Triggers> </Button>"
  },
  "programming/net/net_xml.html": {
    "href": "programming/net/net_xml.html",
    "title": "| Vývojář",
    "summary": "Náhrada znaků Základní znaky: < (levá ostrá závorka) &lt; > (pravá ostrá závorka) &gt; & (ampersand) &amp; ' (apostrof) &apos; \" (uvozovky) &quot; Znaky s diakritikou: Á &Aacute; á &aacute; Č &Ccaron; č &ccaron; Note Stejným způsobem lze následně nahradit i další znaky s diakritikou. s prefixem caron (uvozovky) nebo acute (čárka nad písmenem). CDATA CDATA (Character Data) je způsob, jak vložit data do XML souboru, která by jinak byla interpretována jako XML. <exampleOfACDATA> <![CDATA[ Protože se jedná o sekci CDATA mohu použít všechny druhy vyhrazených znaků jako: > < „ & nebo psát věci jako: <foo></bar> a dokument je stále dobře zformátovaný! ]]> </exampleOfACDATA> Serializace a Deserializace objektu Serializace Proces, kdy se objekt převede na XML soubor. public string SerializeObject(MyObject myObject) { var serializer = new XmlSerializer(typeof(MyObject)); using (var stringWriter = new StringWriter()) { serializer.Serialize(stringWriter, myObject); return stringWriter.ToString(); } } Deserializace Proces, kdy se XML soubor převede zpět na objekt. public MyObject DeserializeObject(string xml) { var serializer = new XmlSerializer(typeof(MyObject)); using (var stringReader = new StringReader(xml)) { return (MyObject)serializer.Deserialize(stringReader); } } Namespace Způsob jak zabránit konfliktu jmen v XML souborech. Note Poznáme podle klíčového slova xmlns u atributu. Warning Pokud je namespace použit, musí se uvést i při zpracování souboru. Note URL namespace v XML dokumentu nemusí být skutečná existující URL adresa. Je to pouze jedinečný identifikátor, který se používá k rozlišení názvů elementů a atributů v XML dokumentu. Tento identifikátor je často ve formě URL pro snadnou identifikaci a jedinečnost, ale nemusí to být nutně platná URL adresa, kterou byste mohli otevřít v prohlížeči. Například: <?xml version=\"1.0\" encoding=\"utf-16\"?> <p:Person xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:p=\"test\"> <p:FirstName>John</p:FirstName> <p:LastName>Doe</p:LastName> <p:Age>30</p:Age> </p:Person> XmlSerializer s = new XmlSerializer(person.GetType()); StringBuilder sb = new StringBuilder(); using (StringWriter writer = new StringWriter(sb)) { XmlSerializerNamespaces ns = new XmlSerializerNamespaces(); ns.Add(\"p\", \"test\"); s.Serialize(writer, person, ns); } XML soubor bez namespace <person> <name>John Doe</name> <age>30</age> </person> Warning Vlastnosti na objektu nesmí mít atribut XmlElement s namespace. XmlSerializer s = new XmlSerializer(person.GetType()); XmlSerializerNamespaces ns = new XmlSerializerNamespaces(); ns.Add(\"\", \"\"); StringBuilder sb = new StringBuilder(); using (StringWriter writer = new StringWriter(sb)) { s.Serialize(writer, person, ns); } Note Řešením jak odebrat namespace úplně všude a nebere v potaz atributy XmlElement s namespace. XDocument document = XDocument.Parse(dataOutput); if (document.Root == null) return; foreach (var element in document.Root.DescendantsAndSelf()) { element.Name = element.Name.LocalName; element.ReplaceAttributes(element.Attributes() .Where(x => !x.IsNamespaceDeclaration) .Select(x => new XAttribute(x.Name.LocalName, x.Value))); } dataOutput = document.ToString(); Pro více info zde. XML soubor s namespace Příklad 1: <?xml version=\"1.0\" encoding=\"utf-16\"?> <Person xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"> <FirstName>John</FirstName> <LastName>Doe</LastName> <Age>30</Age> </Person> XmlSerializer s = new XmlSerializer(person.GetType()); StringBuilder sb = new StringBuilder(); using (StringWriter writer = new StringWriter(sb)) { s.Serialize(writer, person); } Příklad 2: <?xml version=\"1.0\" encoding=\"utf-16\"?> <p:Person xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:p=\"http://www.example.com\"> <p:FirstName>John</p:FirstName> <p:LastName>Doe</p:LastName> <p:Age>30</p:Age> </p:Person> XmlSerializer s = new XmlSerializer(person.GetType()); StringBuilder sb = new StringBuilder(); using (StringWriter writer = new StringWriter(sb)) { XmlSerializerNamespaces ns = new XmlSerializerNamespaces(); ns.Add(\"p\", \"http://www.example.com\"); s.Serialize(writer, person, ns); } Note V tomto kódu \"p\" je prefix pro namespace a \"http://www.example.com\" je URL namespace. Konvence serializace XML Umožňuje přizpůsobit jak se třídy a vlastnosti serializují do XML. Kořenový element Označí třídu, která se má serializovat jako kořenový element Pojmenuje kořenový element. [XmlRoot(\"MyClass\")] public class MyClass { // ... } Ignorovat vlastnosti Označuje vlastnosti, která se nemají serializovat. [XmlIgnore] public string MyProperty { get; set; } Povolit jmenné prostory Označuje, že se mají jmenné prostory serializovat jako atributy. [XmlNamespaceDeclarations] public class MyClass { // ... } Povolit/Zakázat přes metodu ShouldSerialize{PropertyName} je metoda, která se volá při serializaci objektu. Tato metoda se používá k rozhodnutí, zda se daná vlastnost má serializovat. Pokud metoda vrátí true vlastnost {PropertyName} se serializuje Pokud metoda vrátí false vlastnost {PropertyName} se neserializuje public bool ShouldSerializeMyProperty() { // logika rozhodnutí zda serializovat MyProperty } Povolit/Zakázat přes vlastnost bool {PropertyName}Specified je vlastnost typu bool, která se používá k rozhodnutí, zda se má vlastnost serializovat. Toto je alternativa k ShouldSerialize{PropertyName}. {PropertyName}Specified pokud je true vlastnost {PropertyName} se serializuje {PropertyName}Specified pokud je false vlastnost {PropertyName} se neserializuje public bool MyPropertySpecified { get; set; } Pojmenování kolekce a položek v kolekci Používá se k pojmenování kolekce a položek v kolekci. [XmlArray(\"MyCollection\"), XmlArrayItem(\"Item\")] public List<string> MyProperty { get; set; } Xml element ➡ xml atribut Vlastnost, ktera se serializují jako \"XML atribut\" místo jako \"XML element\". [XmlAttribute] public string MyProperty { get; set; } Xml element ➡ textový obsah Označuje vlastnosti, která má serializovat jako obsah XML elementu. To znamená, že vlastnost se serializuje jako textový obsah XML elementu, nikoli jako samostatný element. [XmlText] public string MyProperty { get; set; } Enum ➡ xml element Označuje výčtový typ, který se má serializovat jako XML element. public enum MyEnum { [XmlEnum(\"Value1\")] Value1, [XmlEnum(\"Value2\")] Value2 } Třída ➡ xml element Označí třídu, která se má serializovat jako XML element. [XmlType(\"MyClass\")] public class MyClass { // ... } Třída ze které se dědí ➡ xml element Označuje třídy, které se mají serializovat jako potomky rodičovské třídy. To znamená, že pokud máte třídu MyBaseClass a od ní odvozenou třídu MyDerivedClass, musíte označit MyBaseClass pomocí XmlIncludeAttribute. [XmlInclude(typeof(MyDerivedClass))] public class MyBaseClass { // ... } public class MyDerivedClass : MyBaseClass { // ... } Libovolný xml element Označuje vlastnost, která může obsahovat libovolný XML element. Warning Musí být typu XmlElement[], nebo XmlElement [XmlAnyElement] public XmlElement[] MyProperty { get; set; } Libovolný xml atribut Označuje vlastnost, která může obsahovat libovolný XML atribut. Warning Musí být typu XmlAttribute[], nebo XmlAttribute [XmlAnyAttribute] public XmlAttribute[] MyProperty { get; set; }"
  },
  "programming/netCLI.html": {
    "href": "programming/netCLI.html",
    "title": "| Vývojář",
    "summary": ".NET CLI (Command Line Interface) Important Je zapotřebí mít nainstalovaný .NET SDK (Software Development Kit) a .NET Runtime (Framework) Umístění balíčků Po instalaci, balíčky jsou umístěny v adresáři dle platformy: Windows Umístění: C:\\Program Files\\dotnet\\ Tip Můžete zjistit umístění pomocí příkazu: where dotnet macOS Umístění: : /usr/local/share/dotnet/ Tip Můžete zjistit umístění pomocí příkazu: which dotnet Linux Umístění: /usr/share/dotnet/ nebo /usr/local/share/dotnet/ Tip Můžete zjistit umístění pomocí příkazu: which dotnet Seznam nainstalovaných balíčků dotnet tool list -g Záloha globálních nástrojů Zjištění nainstalovaných globálních nástrojů dotnet tool list -g Important Zaznamenejte názvy a verze nainstalovaných nástrojů, což usnadní jejich opětovnou instalaci. Umístění nástrojů Zálohujte celý adresář tools. Windows C:\\Users\\<uživatelské\\_jméno>\\.dotnet\\tools macOS/Linux ~/.dotnet/tools Obnova globálních nástrojů Obnovení ze zálohy Pokud máte zálohovaný adresář tools, jednoduše zkopírujte jeho obsah zpět do původního umístění. Note Restartovat příkazový řádek nebo terminál, aby se projevily změny. Kontrola instalace Po obnovení zkontrolujte, zda jsou nástroje správně nainstalovány: dotnet tool list -g Příkazy Instalace Globálně: dotnet tool install -g <balíček> Lokálně: dotnet tool install <balíček> Aktualizace Globálně: dotnet tool update -g <balíček> Lokálně: dotnet tool update <balíček> Odinstalace Globálně: dotnet tool uninstall -g <balíček> Lokálně: dotnet tool uninstall <balíček>"
  },
  "programming/nugetPackage.html": {
    "href": "programming/nugetPackage.html",
    "title": "| Vývojář",
    "summary": "Nuget Packages Správa balíčků Způsoby správy balíčků: packages.config Ukládá seznam všech balíčků používaných projektem, včetně jejich závislostí. Každý balíček je nainstalován do specifické složky projektu (typicky packages složka uvnitř řešení). Note Zde jsou balíčky uloženy v projektu a zkopírovány z globální složky, což může zpomalovat buildy a zvětšuje velikost repozitářů. Používané před rokem 2017. V každém projektu je samostatná složka s balíčky a soubor .csproj obsahuje pouze cesty k těmto balíčkům. PackageReference Note Balíčky jsou při použití PackageReference vždy načítány přímo ze složky global-packages (není nutné je kopírovat do projektu, jak to je u packages.config). Balíčky se nestahují do složky projektu, ale do globální složky balíčků. Závislosti se spravují automaticky a nejsou explicitně uvedeny v souboru .csproj. Note Používá balíčky přímo z globální složky global-packages, což zrychluje build a snižuje nároky na prostor v projektu. Od roku 2017 je výchozí formát ve Visual Studiu. Všechny balíčky jsou spravovány na jednom centrálním místě a projekt využívá jejich globální umístění, což vede k lepší přehlednosti a výkonu. Globální složka balíčků Umístění složky: Windows: %userprofile%\\.nuget\\packages Mac/Linux: ~/.nuget/packages Note Výchozí umístění lze upravit přes proměnné prostředí NUGET_PACKAGES"
  },
  "programming/python.html": {
    "href": "programming/python.html",
    "title": "| Vývojář",
    "summary": "Python Balíčky Záloha balíčků pip download <název balíčku> -d <cesta k adresáři> Tento příkaz stáhne balíček keep a všechny potřebné závislosti do specifikované složky, kterou pak můžete použít k instalaci na jiném počítači bez připojení k internetu. Instalace balíčků ze zálohy pip install --no-index --find-links <cesta/k/adresari> Note --no-index říká pipu, aby nehledal balíček online. --find-links říká pipu, kde se nachází stažené balíčky, které má nainstalovat."
  },
  "programming/techniques.html": {
    "href": "programming/techniques.html",
    "title": "| Vývojář",
    "summary": "Vývojové metodiky Techniky vývoje softwaru jsou postupy, které určují, jakým způsobem se vyvíjí software. Agilní metodika (Scrum) Warning Není vhodná pro projekty, které vyžadují pevný plán a jasně definované výstupy. Zaměřuje se na spolupráci, zákaznickou spokojenost a schopnost reagovat na změny. V praxi tým pracuje v krátkých iteracích zvaných sprinty, které trvají obvykle 2-4 týdny. Note Na konci každého sprintu tým prezentuje hotové funkce zákazníkovi a získává zpětnou vazbu. Podrobný postup: Plánování sprintu (Sprint Planning) Týmová schůzka na začátku sprintu, která se koná jednou. Výběr úkolů (z backlogu) pro daný sprint k provedení. Diskutování o tom, jak budou tyto úkoly provedeny. Vývoj Každodenní práce na úkolech, které byly vybrány během plánování sprintu. Každodenní týmová schůzka zvaná: Daily Scrum, kde se diskutuje o pokroku a případných překážkách na úkolech. Testování je součástí této sekce vývoje. Note Jakmile je úkol nebo funkce vyvinuta, je ihned testována, aby se zajistilo, že funguje správně a splňuje požadavky. Toto průběžné testování umožňuje rychlé odhalení a opravu chyb. Revize sprintu (Sprint Review) Týmová schůzka na konci sprintu, která se koná jednou. Prezentuje se práce zákazníkovi a získává se zpětná vazba. Tip Tato schůzka je také příležitostí k diskusi o tom, co se v sprintu povedlo a co ne. Retrospektiva sprintu (Sprint Retrospective) Týmová schůzka obvykle hned po revizi sprintu. Diskutuje se o tom, co se v průběhu sprintu povedlo, co se nepovedlo a jak se mohou věci zlepšit v dalším sprintu. Vodopádová metodika Warning Délka každé fáze závisí na velikosti a složitosti projektu, počtu lidí v týmu a mnoha dalších faktorech. Každá fáze musí být dokončena, než může začít další. Podrobný postup: Analýza požadavků Na začátku projektu se shromažďují a analyzují požadavky. Note Toto zahrnuje porozumění potřebám zákazníka a definování, co bude systém dělat. Návrh Vytváří se podrobný plán toho, jak bude systém fungovat a jak bude vypadat. Implementace Návrh se převede na zdrojový kód. Programátoři píší kód, který realizuje návrh systému. Testování Kontroluje se, zda systém splňuje požadavky definované v první fázi a zda neobsahuje chyby. Nasazení Jakmile je systém otestován a schválen, je nasazen do produkčního prostředí. Údržba Sleduje se výkon systému, opravují se chyby a přidávají se nové funkce podle potřeb zákazníka. Kanban Vizuální systém řízení práce, který se zaměřuje na dokončení úkolů. Warning Není vhodný pro projekty, které vyžadují pevné plány a termíny Note Zaměřuje se na průběžnou dodávku a minimalizaci času stráveného na úkolech. Podrobný postup: Definování úkolů Na začátku se vytvoří seznam úkolů, které je třeba dokončit. Tip Tyto úkoly se zapisují na karty, které se umístí na Kanban tabuli. Vizualizace práce Kanban tabule je rozdělena na několik sloupců, které reprezentují různé stavy úkolu. Tip Například: Backlog, Todo, Done, atd... Karty s úkoly se přesouvají mezi těmito sloupci podle toho, v jakém stavu se nacházejí. Práce na úkolech Tým začne pracovat na úkolech, začínajíc u těch, které jsou nejvíce prioritní. Note Jakmile je úkol dokončen, karta se přesune do dalšího sloupce. Například sloupec: Done Omezení práce v průběhu (Work in Progress, WIP) Kanban klade důraz na omezení množství práce, která se může dělat současně. Note Zvyšuje se efektivita a snižuje se doba, kterou úkol stráví v systému. Průběžné zlepšování Tým pravidelně hodnotí svůj proces a hledá způsoby, jak ho zlepšit. Tip To může zahrnovat změnu počtu úkolů, prioratizaci úkolů atd... Rychlé prototypování Proces pro vytvoření funkčního modelu projektu co nejrychleji, aby bylo možné testovat a iterovat nápady. Note V kontextu Unity to znamená vytvoření základní verze hry nebo aplikace, která zahrnuje pouze klíčové mechaniky a funkce. Rychlá iterace Rychle testovat a provádět nápady. Pokud vytvoříte prototyp, zkuste ho co nejdříve otestovat a získat zpětnou vazbu. Poté můžete na základě této zpětné vazby upravit a vylepšit svůj prototyp. Important Cílem je vytvořit funkční model vašeho projektu, ne dokonalý produkt. Nebojte se udělat kompromisy v kvalitě, pokud to znamená, že můžete rychleji testovat a iterovat své nápady. Postup Definice konceptu Než se začne s prototypováním, měli byste mít jasnou představu o tom, co chcete vytvořit. Tip To může zahrnovat definování klíčových mechanik, funkcí a cílů vašeho projektu. Vytvoření základní scény v Unity Tip Tato scéna bude sloužit jako základ pro váš prototyp. Přidání základních objektů Přidejte do scény základní objekty, jako jsou krychle, koule a válce, které můžete použít k reprezentaci různých prvků ve vaší hře. Přidání mechanik a funkcí Použijte skriptování a vestavěné nástroje Unity k přidání mechanik a funkcí do vašeho prototypu. Testování a iterace Jakmile máte základní prototyp, začněte ho testovat. Note Získejte zpětnou vazbu od ostatních a na základě této zpětné vazby upravte a vylepšujte svůj prototyp. Opakování procesu Po provedení změn na svém prototypu ho znovu otestujte a pokračujte v tomto cyklu, dokud nejste spokojeni s výsledkem. Tip Rychlé prototypování je iterativní proces. Pojmenování BEM BEM = \"Block Element Modifier\" Metodika pro pojmenování tříd v HTML a CSS. Note Pomáhá udržet váš kód organizovaný a snadno pochopitelný, a to i pro ostatní vývojáře, kteří se na váš kód podívají. Příklad: <div class=\"block\"> <!-- Block --> <div class=\"block__element\"> <!-- Element --> </div> <div class=\"block__element--modifier\"> <!-- Element with modifier --> </div> </div> .block { ... } .block__element { ... } .block__element--modifier { ... } Block Jedná se o samostatnou entitu, která má smysl sama o sobě. Například: header, container, menu, checkbox, atd. Element Část bloku, která nemá samostatný význam. Je semanticky vázána na svůj blok. Například: menu item, list item, checkbox caption, atd. Modifier Varianta bloku nebo prvku, která mění vzhled nebo chování. Například: disabled, highlighted, checked, atd. Syntax BEM Názvy bloků a elementů jsou odděleny dvěma podtržítky: __ Názvy modifikátorů jsou odděleny dvěma pomlčkami: -- Použití v kódu Jasné a popisné názvy Názvy proměnných, funkcí, tříd atd. by měly být dostatečně popisné, aby bylo jasné, co dělají nebo co reprezentují. Například: Místo: p, použijte: product místo: calc, použijte: calculateAverage. Tip Vyhněte se používání zkratek a akronymů. Boolovské proměnné Boolovské proměnné by měly začínat předponou jako: is, has, can atd., které naznačují, že hodnota může být pravdivá nebo nepravdivá. Například: isAvailable, hasPermission, canExecute. Názvy funkcí Funkce by měly začínat slovesem, které popisuje, co funkce dělá. Například: getUserName(), calculateTotalPrice(), printReport(). Konzistentní názvosloví Pokud se rozhodnete pro určitý styl názvosloví, buďte konzistentní v jeho používání po celém kódu. Například: pokud používáte camelCase pro názvy proměnných, používejte je všude. Jednotné názvy pro stejné typy proměnných Pokud máte více polí. Například:firstArray, secondArray. Množné čísla (plurál) pro kolekce Pokud proměnná reprezentuje kolekci objektů, použijte množné číslo. Například:users, products, items. Konstanty pro \"magické\" hodnoty Pokud kód obsahuje \"magické\" hodnoty, které nejsou okamžitě zřejmé, zvažte jejich nahrazení pojmenovanými konstantami. Například: místo: if (status == 1), použijte: if (status == STATUS_ACTIVE)."
  },
  "programming/unity.html": {
    "href": "programming/unity.html",
    "title": "| Vývojář",
    "summary": "Rychlejší spuštění Reload Domain Když je tato možnost povolena, všechny skripty se znovu načtou, což může trvat déle, ale zajišťuje, že se všechny změny v kódu projeví. Reload Scene Když je tato možnost povolena, Unity znovu načte aktuální scénu, což může být užitečné, pokud chceš začít s \"čistým\" stavem. Pokud tyto možnosti zakážeš, můžeš zrychlit vstup do režimu hry, protože Unity se vyhne některým časově náročným procesům. Výběr hry 2D či 3D Rychlé prototypování Klíčová slova Vývojové vzory"
  },
  "programming/unity/2d.html": {
    "href": "programming/unity/2d.html",
    "title": "| Vývojář",
    "summary": "2D Tilemap x Sprite Renderer Tilemap Vykreslit a nastavit barvu na dlaždici Important Z nějakého důvodu kód funguje pouze pokud je to takto oddělený. public void GenerateTilemap(int width, int height, Color color) { // Delete all tiles this.ClearTiles(); for (int x = 0; x < width; x++) for (int y = 0; y < height; y++) { this.Tilemap.SetTile(new(x, y, 0), this.TileBase); } for (int x = 0; x < width; x++) for (int y = 0; y < height; y++) { this.Tilemap.SetColor(new(x, y, 0), color); } } Pravidla pro Tilemap Velikost obrázku Definice velikostí Note Používají se mocniny čísla 2. Například: 16x16 px, 32x32 px, 64x64 px, 128x128 px, 256x256 px, 512x512 px, atd... 16x16 px Ikony a jednoduché grafiky Používá se pro základní UI prvky a malé ikony. Vzdálenost od kamery: Velmi daleko, nedůležitý detail. 32x32 px Malé UI prvky Ideální pro malé ikony a základní grafiky v uživatelském rozhraní. Vzdálenost od kamery: Velmi daleko, nedůležitý detail. 64x64 px Menší objekty Vhodné pro objekty s mírným detailem, jako jsou malé herní prvky. Vzdálenost od kamery: Střední vzdálenost, detail je stále mírně rozmazaný. 128x128 px Střední objekty Dobré pro středně velké herní prvky a detaily v prostředí. Vzdálenost od kamery: Blízká vzdálenost, viditelný detail. 256x256 px Větší objekty a detailní textury Používá se pro detailnější objekty a textury v herním prostředí. Vzdálenost od kamery: Střední až blízká vzdálenost, detailní zobrazení. 512x512 px Velmi detailní objekty Vhodné pro blízké záběry a detailní textury. Vzdálenost od kamery: Blízká vzdálenost, vysoká úroveň detailu. 1024x1024 px Velké objekty a textury Ideální pro velmi detailní textury a objekty z blízka. Vzdálenost od kamery: Velmi blízká vzdálenost, extrémní detail. 2048x2048 px a více Maximální detail Nejvyšší kvalita textur pro extrémně detailní objekty a prostředí. Vzdálenost od kamery: Extrémně blízká vzdálenost, maximální detail. Nastavení velikosti Například obrázek o velikosti 64x64 pixelů. Warning Pixel Per Unit (PPU) - kolik pixelů je na jednotku v Unity. Určuje velikost Sprite Je důležité nastavit dle velikosti grafiky, aby byla správně zobrazena. Například pro obrázky o velikosti 256x256 pixelů ve sprite sheet, použijeme PPU 256 na sprite sheet. Příklad: Vytvořit dlaždici o velikosti 1x1 jednotka. Pokud nastavíte PPU na 32, pak sprite o rozměrech 32x32 dokonale zabere celou dlaždici (1x1). Nyní chcete dlaždici 2x2, pak byste nastavili PPU 16, takže pro každou jednotku použije 16 pixelů ze spritu. (16 / 32 = 2 jednotky). Například pro dlaždici o velikosti 1x2, pokud byste nastavili PPU 32, tak by rozměr obrázku byl 32x16 px. (32/32 = 1, 32/16=2) px Pro více informací zde. Animace obrázku Hloubka (Depth) u kostí Important Ovlivňuje pořadí vykreslení vybraného Sprite (Sprite Mesh). Příklad: Pokud máte levou paži (arm L), která je ovlivněna třemi kostmi. Nastavíte například hloubku jedné z kostí forearm_l na -5, zatímco ostatní kosti budou mít hloubku 0. Tak se tato forearm_l vykreslí pod ostatními částmi tohoto Sprite Mesh. Otevřít Sprite Editor Přepnout do Skinning Editor Note Aktivovat Visibility, pokud není aktivní Nastavit u kostí depth Univerzální Rigging Otevřít Sprite Editor Přepnout do Skinning Editor Note Aktivovat Visibility, pokud není aktivní Vytvořit kosti (bones) Nastavit Geometry a Weights Important Pokud se nevykresluje barevně část, která je ovlivněna kostí, může to být způsobeno tímto nastavením: Ujistěte se, že máte oba posuvníky posunuté úplně do prava. Zkopírovat rig Otevřít nový sprite Vložit rig Řešení chyb při vykreslování sprite Important Na kameře musí být přidána komponenta Pixel Perfect Camera pro 2D Zabraňuje deformacím, rozmazání a trhání obrazu Černé čáry Problém, viz. níže: Řešení: Zkontrolujte obrázek, zda je správně umístěn. Note Upravit obrázek hlavy, aby byla umístěna uvnitř rozsahu Caution Takto vypadá špatně umístěný obrázek v dokumentu Nastavit padding v TexturePacker Note Pomůže zabránit problémům, jako je \"bleeding\" efekt. (Přetekání obrázku přes okraje.) Nastavte libovolnou velikost výplně, která bude větší než 0 pro: Border padding Mezera kolem okrajů celého sheetu. Note Pomáhá předejít vizuálním artefaktům (nechtěným chybám jako jsou rozmazání nebo barevné okraje) na okrajích sheetu. Shape padding Mezera mezi jednotlivými sprites na sheetu. Note Zabraňuje vzájemnému překrývání a nežádoucím vlivům mezi jednotlivými sprites. Tip Objeví-li se později znovu černé čáry, stačí zvýšit velikost výplně (padding) Problikávání Zkontrolujte měřítko v herním okně, že je nastaveno na 1x"
  },
  "programming/unity/animation.html": {
    "href": "programming/unity/animation.html",
    "title": "| Vývojář",
    "summary": "UMotion Uložení změn Existuje několik způsobů (můžete použít kterýkoli z těchto 3): Pomocí \"Key Selected\" vytvořte/upravte klíče pro vybrané kosti/transformace Povolte \"Auto Key\", aby UMotion automaticky vytvořil klíče/upravil klíče Použijte \"Key Dialog\" pro získání pěkného přehledu o tom, co jste změnili a co by mělo být klíčováno"
  },
  "programming/unity/camera.html": {
    "href": "programming/unity/camera.html",
    "title": "| Vývojář",
    "summary": "Kamera Important Pro 2D hry musí být přidána komponenta \"Pixel Perfect Camera\", která zabrání deformacím, trhání obrazu atd.. Ortografická Kamera Zobrazení: Objektivní (bez perspektivního zkreslení). Velikost objektů: Všechny objekty vypadají stejně velké bez ohledu na jejich vzdálenost od kamery. Použití: Ideální pro 2D hry, izometrické zobrazení, architektonické vizualizace. Nastavení: Používá Orthographic Size k určení velikosti záběru kamery. Zobrazení linie: Rovnoběžné linie zůstávají rovnoběžné. Perspektivní Kamera Zobrazení: Simuluje reálnou perspektivu (s perspektivním zkreslením). Velikost objektů: Objekty se jeví menší, jak se vzdálí od kamery. Použití: Vhodné pro 3D hry, kde je důležitý realistický pocit hloubky. Nastavení: Používá Field of View (FOV) k určení šířky záběru kamery. Zobrazení linie: Rovnoběžné linie se sbíhají do jednoho bodu (vanishing point). Novinky"
  },
  "programming/unity/navigation.html": {
    "href": "programming/unity/navigation.html",
    "title": "| Vývojář",
    "summary": "Navigační systém pro pohyb Novinky"
  },
  "programming/unity/renderer.html": {
    "href": "programming/unity/renderer.html",
    "title": "| Vývojář",
    "summary": "URP = Universal Renderer Pipeline DefaultVolumeProfile Sada výchozích nastavení pro Volume efekty. Definuje základní vizuální efekty a post-processing efekty, které jsou použity v rámci projektu. Note Obsahuje standardní efekty, jako jsou bloom, chromatic aberration, a další, které mohou být použity jako výchozí profil. UniversalRenderPipelineGlobalSettings Globální nastavení pro Universal Render Pipeline (URP). Note Určuje základní chování a vlastnosti URP v projektu, jako jsou například nastavení pro HDRP nebo další globální nastavení pipeline. URP Render Pipeline Asset Hlavní asset pro konfiguraci Universal Render Pipeline (URP). Umožňuje nastavit konkrétní parametry render pipeline, jako jsou kvalita, efekty a optimizace pro rendering. Note Obsahuje konfigurace pro renderování a zpracování obrazu, jako jsou nastavení pro antialiasing, renderování stínů a další. URP Renderer Data Konfigurace specifická pro jednotlivé renderery v rámci URP. Note Definuje specifické nastavení pro různé renderery (např. Forward Renderer), jako jsou nastavení pro stíny, efekty a post-processing na úrovni renderování. Může obsahovat specifická nastavení pro různé renderování (např. různé typy renderovaných objektů, různé metody renderování atd.)."
  },
  "programming/unity/scriptableObject.html": {
    "href": "programming/unity/scriptableObject.html",
    "title": "| Vývojář",
    "summary": "Skriptovatelné Objekty Nemusí se vytvářet ve scéně, jsou namísto toho vytvořeny již v projektu. Important ScriptableObjects se po zavření a opětovném otevření hry obnoví na výchozí hodnoty. Singleton"
  },
  "programming/unity/ui.html": {
    "href": "programming/unity/ui.html",
    "title": "| Vývojář",
    "summary": "UI Původní systém pro vytváření uživatelského rozhraní v Unity. Tlačítko (Button) Rozsah detekce kliknutí (dle průhlednosti obrázku) alphaHitTestMinimumThreshold je používána u komponenty Image Určuje minimální prahovou hodnotu alfa (průhlednosti), při které bude kliknutí na tento obrázek zaregistrováno. Nabývá rozsah hodnoty (0 až 1) Hodnota 0 znamená, že kliknutí bude zaregistrováno i na úplně průhledných částech obrázku. Hodnota 1 znamená, že kliknutí bude zaregistrováno pouze na zcela neprůhledných částech obrázku. Například, pokud nastavíme alphaHitTestMinimumThreshold na 0.5, kliknutí bude zaregistrováno pouze na částech obrázku, které mají alfa hodnotu alespoň 0.5 (tedy nejsou příliš průhledné). Příklad použití: using UnityEngine; using System.Collections; using UnityEngine.UI; // Required when Using UI elements. public class ExampleClass : MonoBehaviour { public Image theButton; // Use this for initialization void Start() { theButton.alphaHitTestMinimumThreshold = 0.5f; } } Tip Lze použít například při tvorbě kruhového tlačítka."
  },
  "programming/unity/uiToolkit.html": {
    "href": "programming/unity/uiToolkit.html",
    "title": "| Vývojář",
    "summary": "UI Toolkit UI Toolkit je nový systém pro vytváření uživatelského rozhraní v Unity. Novinky"
  },
  "teamwork/outlook.html": {
    "href": "teamwork/outlook.html",
    "title": "| Vývojář",
    "summary": "Zobrazení Sloučení/Oddělení panelů kalendáře View ➡ Overlay Pokud je vypnuto, každý kalendář se zobrazí v samostatném okně Pokud je zapnuto, kalendáře se zobrazí v jednom okně"
  },
  "vcs/git/branches/createRemoteBranch.html": {
    "href": "vcs/git/branches/createRemoteBranch.html",
    "title": "| Vývojář",
    "summary": "Pro umístění (pushnutí) nové větve develop na Git server (např. GitHub, GitLab) postupuj takto: Vytvoř branch develop (pokud ji ještě nemáš): git checkout -b develop Ujisti se, že máš vzdálený repozitář: git remote -v Note Pokud není nastaven, použij např. git remote add origin <url> Pushni větev develop na remote: git push -u origin develop Note Parametr -u nastaví develop jako výchozí sledovanou větev vůči origin/develop. Ověř, že větev je online: Lze se nyní podívat na webové rozhraní (GitHub, GitLab apod.), jestli se větev vzdáleně objevila."
  },
  "vcs/git/branches/deleteRemoteBranch.html": {
    "href": "vcs/git/branches/deleteRemoteBranch.html",
    "title": "| Vývojář",
    "summary": "Warning Smazání vzdálené větve je nevratná operace. Ujisti se, že větev už nepotřebuješ a že všechny potřebné změny byly začleněny do jiných větví. Pro smazání vzdálené větve z Git serveru (např. GitHub, GitLab) postupuj takto: Zobraz si seznam všech větví (lokální i vzdálené): git branch -a Smaž vzdálenou větev jedním z těchto příkazů: git push origin --delete <nazev-vetve> # nebo kratší varianta git push origin :<nazev-vetve> Note Nahraď <nazev-vetve> skutečným názvem větve, kterou chceš smazat. Vyčisti lokální reference na smazané vzdálené větve: git fetch --prune Tip Tento krok není povinný, ale pomáhá udržet lokální repozitář čistý."
  },
  "vcs/git/branches/pullRequest.html": {
    "href": "vcs/git/branches/pullRequest.html",
    "title": "| Vývojář",
    "summary": "\uD83D\uDFE9 Kdy použít Pull Request (PR): Týmová spolupráce – ostatní vývojáři mají možnost kód zkontrolovat. Code review, komentáře, schválení. Automatizované testy a CI/CD pipeline se spustí před sloučením. Audit a historie – vše je dohledatelné, kdo co schválil a proč. ✅ Typické v profesionálních projektech, GitHub, GitLab, Bitbucket atd. \uD83D\uDFE8 Kdy použít přímo git merge: Jsi sám na projektu nebo děláš rychlý merge bez potřeby review. Chceš rychle sloučit větev lokálně (např. feature/login do develop). Nepotřebuješ historii PR ani schvalovací proces. git checkout develop git merge feature/login-page ⚠️ Tento merge probíhá bez schválení a obvykle lokálně – pak je třeba pushnout změny. \uD83E\uDDE0 Shrnutí Scénář Použij PR? Použij Merge? Pracuješ sám ❌ ✅ Týmový projekt ✅ ❌ (většinou) Chceš review, testy, audit ✅ ❌ Lokální rychlé sloučení ❌ ✅"
  },
  "vcs/git/gitConfig.html": {
    "href": "vcs/git/gitConfig.html",
    "title": "| Vývojář",
    "summary": "Uživatelská konfigurace Porovnání souborů přes aplikaci Meld Windows git config --global diff.tool meld git config --global difftool.meld.path \"C:\\Program Files\\Meld\\Meld.exe\" git config --global difftool.prompt false git config --global merge.tool meld git config --global mergetool.meld.path \"C:\\Program Files\\Meld\\Meld.exe\" git config --global mergetool.prompt false Linux git config --global diff.tool meld git config --global difftool.meld.path \"/usr/bin/meld\" git config --global difftool.prompt false git config --global merge.tool meld git config --global mergetool.meld.path \"/usr/bin/meld\" git config --global mergetool.prompt false"
  },
  "vcs/git/gitFlow.html": {
    "href": "vcs/git/gitFlow.html",
    "title": "| Vývojář",
    "summary": "Git Flow Git Flow je strategie pro správu větví v Gitu, která usnadňuje práci v týmech a řízení verzí softwaru. Základní větve v Git Flow main (nebo master): Obsahuje produkční verzi kódu develop: Obsahuje připravované změny pro příští vydání Pomocné větve feature/*: Pro vývoj nových funkcí release/*: Pro přípravu vydání hotfix/*: Pro rychlé opravy chyb v produkci Vývoj nové funkce # Vytvoření nové feature větve git checkout develop git checkout -b feature/nova-funkce # Po dokončení vývoje git checkout develop git merge feature/nova-funkce Note Vždy vytvářejte feature větve z aktuální develop větve. Příprava vydání # Vytvoření release větve git checkout develop git checkout -b release/1.0.0 # Po dokončení příprav git checkout main git merge release/1.0.0 git checkout develop git merge release/1.0.0 git tag -a v1.0.0 -m \"Verze 1.0.0\" Tip V release větvích se typicky provádí pouze opravy chyb, finální úpravy dokumentace a příprava metadat verze. Oprava chyby v produkci # Vytvoření hotfix větve git checkout main git checkout -b hotfix/oprava-chyby # Po dokončení opravy git checkout main git merge hotfix/oprava-chyby git tag -a v1.0.1 -m \"Oprava 1.0.1\" git checkout develop git merge hotfix/oprava-chyby Important Hotfixy se vždy slučují jak do main, tak do develop větve! Pravidla pro práci s Git Flow Nikdy nepracujte přímo v main ani develop větvích Každá funkce má vlastní feature větev Před sloučením proveďte code review Po sloučení release nebo hotfix větve označte verzi pomocí Git tagu Používejte smysluplné názvy větví (např. feature/user-authentication) Udržujte commit zprávy jasné a popisné Vizualizace Git Flow main ●────────●─────────●────────● \\ \\ \\ \\ develop ●─────●───●─────●───●───●────● \\ / / / feature ●───● / / / / release ●─────● / hotfix ● Pro více informací navštivte oficiální dokumentaci Git Flow"
  },
  "vcs/git/history/deleteCommits.html": {
    "href": "vcs/git/history/deleteCommits.html",
    "title": "| Vývojář",
    "summary": "Nahrazení Vzdálené Branch z Lokální Branch Přepnout se na novou branch git checkout --orphan latest_branch Note --orphan znamená, že vytvoří branch bez historie commitů Přidat všechny soubory. git add -A Provedení commitu. git commit -am \"Initialize commit\" Tip -am je zkrácený zápis Je to stejné jako zápis: --all --message \"commit message\" Smazat hlavní branch. Warning Zjistěte název hlavní větve. (Většinou se jmenuje master nebo main) git branch -D main Přejmenovat aktivní branch na branch z předchozího kroku. Warning Zjistěte název hlavní větve. (Většinou se jmenuje master nebo main) git branch -m main Odeslat změny z pracovního adresáře do centrálního úložiště git push -f origin main Tip -f (force) = Historie commitů v centrálním úložišti je nahrazena historií z pracovního adresáře"
  },
  "vcs/git/history/fixCommits.html": {
    "href": "vcs/git/history/fixCommits.html",
    "title": "| Vývojář",
    "summary": "fixup! = Nepoužije zprávu z commitu do opravy git commit --fixup <hashId> nebo git commit -m \"fixup! <hashId> notUsedMessage\" squash! = Sloučí zprávu z commitu do opravy git commit -m \"squash! <hashId> optionalCustomMessage\" Příklad Vytvořit nový commit: git commit --fixup <hashId> Note <hashId> = id commitu na který chcete aplikovat opravu Provedení rebase git rebase -i --autosquash head~<n> Note --autosquash = setřídí commity pro opravu s označením fixup! či squash! <n> = počet posledních commitů Otevře se textový editor Pokud jsme zde provedli změny, tak musíme uložit soubor. Nakonec zavřít soubor Note Po zavření souboru se začne vykonávat rebase. Pokud proběhl rebase dokonce, veškeré opravy budou aplikovány."
  },
  "vcs/git/history/moveCommits.html": {
    "href": "vcs/git/history/moveCommits.html",
    "title": "| Vývojář",
    "summary": "Nová Branch git checkout master # Přepne se do zdrojové branch git branch newbranch # Vytvoří branch a tím se uloží stejné commity z předchozí aktivní branch git checkout master # Přepne se do zdrojové branch git reset --hard HEAD~3 # Odstraní 3 commity zpět. git checkout newbranch # Přepne se do cílové branch Více info zde. Existující Branch git checkout existingbranch # Přepne se do cílové existující branch git merge branchToMoveCommitFrom # Přesune commity ze zdrojové branch git checkout branchToMoveCommitFrom # Přepne se do zdrojové branch git reset --hard HEAD~3 # Odstraní 3 commity zpět git checkout existingbranch # Přepne se do cílové existující branch Více info zde."
  },
  "vcs/git/history/updateGitignore.html": {
    "href": "vcs/git/history/updateGitignore.html",
    "title": "| Vývojář",
    "summary": "Aktualizace .gitignore Odstraňte mezipaměť všech souborů: git rm -r --cached . Jakmile vymažete existující mezipaměť, přidejte/stage soubor/soubory v aktuálním adresáři: git add . Potvrďte změny: git commit -m \"Aktualizace .gitignore\""
  },
  "vcs/git/repository.html": {
    "href": "vcs/git/repository.html",
    "title": "| Vývojář",
    "summary": "Úložiště Vytvořit na lokálním prostředí git init --bare <cesta> Warning <cesta> = vytvoří úložiště do cesty, musí mít na konci cesty .git Použít do pracovního prostředí git clone <cesta> Warning <cesta> = adresa k úložišti, musí mít na konci cesty .git Tip Cesta může být lokální i online."
  },
  "vcs/git/submodules.html": {
    "href": "vcs/git/submodules.html",
    "title": "Git Submodules | Vývojář",
    "summary": "Git Submodules Umožňuje vložit jeden Git repozitář do jiného jako podadresář, přičemž si oba repozitáře zachovávají nezávislost. Submoduly řeší problém, kdy potřebujete: Zahrnout externí kód do svého projektu Udržovat přesnou verzi závislostí Pracovat na více souvisejících projektech současně Základní struktura HlavniProjekt/ ├── .git/ # Git repozitář hlavního projektu ├── .gitmodules # Konfigurace submodulů ├── BeznyAdresar/ # Běžný adresář v hlavním projektu └── Submodul/ # Podadresář obsahující submodul └── .git/ # Samostatný git repozitář Základní příkazy Přidání submodulu # Syntaxe: git submodule add [URL] [cesta] git submodule add https://github.com/uzivatel/knihovna libs/knihovna Klonování projektu se submoduly # Způsob 1: Vše najednou git clone --recursive https://github.com/uzivatel/projekt # Způsob 2: Nejprve projekt, pak inicializace submodulů git clone https://github.com/uzivatel/projekt git submodule init git submodule update Aktualizace submodulů # Aktualizace všech submodulů na nejnovější commit z remote git submodule update --remote # Aktualizace konkrétního submodulu cd cesta/k/submodulu git checkout main git pull cd ../.. git add cesta/k/submodulu git commit -m \"Aktualizován submodul na nejnovější verzi\" Praktický příklad použití v Unity projektu Vhodná struktura UnityProjekt/ ├── .git/ ├── .gitmodules └── Assets/ ├── Game/ # Váš herní kód (součást hlavního repozitáře) └── Plugins/ # Složka pro externí knihovny ├── UI-Framework/ # Submodul s UI frameworkem │ └── .git/ └── Network/ # Submodul s síťovou knihovnou └── .git/ Vytvoření této struktury # Vytvoření hlavního repozitáře cd UnityProjekt git init # Přidání UI frameworku jako submodulu git submodule add https://github.com/author/ui-framework Assets/Plugins/UI-Framework # Přidání síťové knihovny jako submodulu git submodule add https://github.com/author/network-lib Assets/Plugins/Network Tipy pro práci se submoduly Přepínání mezi verzemi cd cesta/k/submodulu git checkout v2.0.0 cd ../.. git add cesta/k/submodulu git commit -m \"Změněna verze submodulu na v2.0.0\" Úpravy v submodulu # Změny v submodulu cd cesta/k/submodulu git checkout -b oprava-chyby # proveďte změny git commit -am \"Oprava chyby\" git push origin oprava-chyby # vytvořte pull request v repozitáři submodulu Odstranění submodulu # 1. Odebrat z .gitmodules git submodule deinit cesta/k/submodulu # 2. Odebrat z .git/config git rm --cached cesta/k/submodulu # 3. Smazat adresář rm -rf cesta/k/submodulu rm -rf .git/modules/cesta/k/submodulu # 4. Commit git commit -m \"Odstraněn submodul\" Časté problémy a řešení Submodul v \"detached HEAD\" stavu cd cesta/k/submodulu git checkout main Submodul ukazuje změny i když žádné nemáte git submodule update Změna URL submodulu git config --file=.gitmodules submodule.nazev.url NOVA_URL git submodule sync Kontrola stavu submodulů git submodule status Výhody a nevýhody Výhody submodulů Přesná kontrola verzí externích knihoven Možnost přímo upravovat a přispívat do závislostí Lepší organizace kódu v komplexních projektech Nevýhody submodulů Vyšší složitost správy repozitáře Nutnost vždy aktualizovat hlavní repozitář po změnách v submodulech Strmější učící křivka pro nové členy týmu"
  },
  "video/obs.html": {
    "href": "video/obs.html",
    "title": "| Vývojář",
    "summary": "OBS (Open Broadcast Software) Argumenty Argument Popis --help, -h Získat seznam dostupných parametrů. --version, -v Získat verzi OBS.* --startstreaming Automaticky spustí streamování. --startrecording Automaticky spustí nahrávání. --startvirtualcam Automaticky spustí virtuální kameru. --startreplaybuffer Automaticky spustí Replay Buffer. --collection \"name\" Spustí s danou sbírkou scén. --profile \"name\" Spustí s daným profilem. --scene \"name\" Spustí s danou scénou. --studio-mode Spustí s aktivním režimem Studio. --minimize-to-tray Spustí minimalizováno do systémové lišty. --portable, -p Použijte přenosný režim. --multi, -m Nebude varovat při spuštění více instancí. --always-on-top Spustí v režimu \"vždy nahoře\". --verbose Učiní protokol podrobnějším. --unfiltered_log Zakáže filtr logu (nepotlačuje opakující se řádky). --disable-updater Zakáže vestavěný updater (pouze Windows/macOS). --allow-opengl Povolit OpenGL renderer na Windows. --only-bundled-plugins Spustí pouze s vestavěnými moduly. --safe-mode Donutí OBS spustit v nouzovém režimu, zakáže všechny třetí strany pluginy, skripty a websockety. --disable-shutdown-check Zakáže detekci neuklizeného vypnutí, které by vyvolalo spuštění v nouzovém režimu. --disable-missing-files-check Zakáže dialog o chybějících souborech, který se může objevit při spuštění. Tip Příklad automatického nahrávání skrze batch: start /d \"C:\\Program Files\\obs-studio\\bin\\64bit\" obs64.exe --startrecording"
  },
  "virtualization/docker.html": {
    "href": "virtualization/docker.html",
    "title": "| Vývojář",
    "summary": "Docker Instalace Important Pro instalaci Dockeru na Windows potřebujete mít nainstalovaný WSL (Windows Subsystem for Linux). Návod na instalaci WSL najdete v sekci WSL. Základní informace Vysvětlení dockeru Docker je platforma pro vývoj, doručování a běh aplikací pomocí kontejnerizace. Izoluje aplikace se všemi jejími knihovnami, konfiguračními soubory a dalšími závislými soubory do kontejnerů. Note Kontejnery zajišťují, že aplikace mohou být spuštěny v jakémkoli prostředí. Docker se stará o celý životní cyklus kontejnerů. Kontejner ➜ Vytvoření ➜ Spuštění ➜ Zastavení Tip Kontejnerizace je virtualizací jádra operačního systému. > > Všechny kontejnery běží v rámci jednoho operačního systému a sdílejí paměť, knihovny a další zdroje. Zdroje se tímto způsobem využívají efektivnější než klasická virtualizace. > > Spuštění kontejneru je navíc mnohem rychlejší než spuštění virtuálního stroje s instalací operačního systému. Malá režie a na stejném hardwaru můžete spustit více docker kontejnerů než virtuálních strojů Soubory dockeru Seznam souborů: dockerd.exe Spouští Docker Daemon, což je hlavní služba, která spravuje kontejnery a poslouchá na socketu či TCP portu. docker.exe Klientský nástroj, který posílá příkazy daemonu (např. docker run, docker ps). docker-compose.exe Umožňuje definovat a spouštět více Docker kontejnerů jako součásti jedné aplikace. Pomocí souboru docker-compose.yml můžete definovat všechny služby (kontejnery), které mají běžet, včetně jejich konfigurací, závislostí a propojení mezi nimi. docker-compose.yml Konfigurační soubor, který popisuje, jaké kontejnery (služby) mají být spuštěny, jaké obrazové soubory mají používat, jaké porty mají být mapovány a jaké další nastavení kontejnery potřebují. Tento soubor je zpracován příkazem docker-compose up, který automaticky spustí všechny definované kontejnery. Základní pojmy Sezmam základních pojmů: dockerfile Textový soubor s instrukcemi k vytvoření Docker image. Specifikuje operační systém, na kterém bude běžet kontejner, jazyky, lokace, porty a další komponenty. docker image Komprimovaná, samostatná část softwaru vytvořená příkazy v Dockerfile. Je to \"šablona\" (aplikace plus požadované knihovny a binární soubory) potřebná k vytvoření a spuštění Docker kontejneru. docker run Příkaz, který spouští kontejnery. Note Každý kontejner je instancí jednoho image. docker hub Oficiální úložiště pro sdílení docker image. Tip Obsahuje officiální docker image z open-source projektů a neoficiální od komunity. Možnost pracovat i s lokálními docker úložišti. docker engine Jádro softwaru docker. Technologie na principu klient-server, která vytváří a provozuje kontejnery. docker compose Definice ke spuštění více kontejnerů. Práce s dockerem Příkazy Zobrazení Zobrazit běžící kontejnery docker ps Zobrazit všechny docker image docker images Aktualizace nastavení Zapnout automatické spouštění kontejneru docker update --restart=yes <container name or id> Vypnout automatické spouštění kontejneru docker update --restart=no <container name or id> Stažení Stáhnout docker image docker pull <Image name> Note <Image name> = Je název docker image. (Například: mcr.microsoft.com/dotnet/core/sdk:3.1) Záloha Zálohovat docker image docker save -o <path to tar file> <docker image name or id> Note <path to tar file> = Cesta k souboru, kam chcete zálohu uložit. <docker image name> = Název docker image, který chcete zálohovat. Například: docker save -o dotnet-sdk.tar mcr.microsoft.com/dotnet/core/sdk:3.1 Obnova Obnova docker image docker load -i <path to tar file> Note <path to tar file> = Cesta k souboru, který chcete obnovit. Příklad: docker load-i dotnet-sdk.tar Vytoření Sestavení docker image docker build [-t] customFolder Sestaví kontejner pro docker image ve vybraném adresáři. Note customFolder Název vybraného adresáře k sestavení docker image. Může být například aktuální adresář: ., nebo jakkoli jinak. -t Pojmenování image a tagu. (Pokud není zadán parametr -t, použije se tag: latest) Příklad: docker build -t myapp . Note myapp = Název pro nově sestavený kontejner. (Může být jakýkoli.) . = Pracovní adresář v dockeru. (V tomto příkladu kořenový adresář.) Spuštění Spustit služby definované v docker-compose.yml docker-compose up Note Spustí všechny služby definované v souboru docker-compose.yml v aktuálním adresáři. Tip Použijte -d pro spuštění na pozadí: docker-compose up -d Pro sestavení a spuštění použijte: docker-compose up --build Pro zastavení služeb použijte: docker-compose down Spuštění kontejneru z docker image docker run <docker image> Spustí kontejner pro docker image. docker run kitematic/hello-world-nginx Tip Spustí docker kontejner s docker image: kitematic/hello-world-nginx Spustit na jiném portu docker run -p 70:80 kitematic/hello-world-nginx Note -p = Mapuje port 70 na hostitelském stroji na port 80 uvnitř kontejneru. (To znamená, že pokud aplikace uvnitř kontejneru poslouchá na portu 80, bude přístupná na portu 70 hostitelského stroje.) kitematic/hello-world-nginx = Název docker image ke spuštění. Spustí a smaže container po ukončení docker run --rm kitematic/hello-world-nginx Note --rm Docker automaticky odstraní kontejner, když je běh kontejneru přerušení. Tip Užitečné, pokud nechcete, aby se vaše lokální úložiště naplnilo zastavenými kontejnery. Spustit v interaktivním módu docker run -it kitematic/hello-world-nginx Note Užitečné, pokud chcete spustit kontejner a poté v něm spustit další příkazy, například při ladění nebo vývoji. Spuštění více kontejnerů z docker image najednou Note Musíte použít soubor YAML k definování služeb vaší aplikace. Následně pomocí jediného příkazu docker-compose up můžete vytvořit a spustit všechny služby definované ve vašem souboru docker-compose.yml. Tip Automaticky použije lokální docker image, pokud je k dispozici. Příklad souboru docker-compose.yaml: # Verze Docker Compose souboru version: '3.4' # Definice služeb services: # Název služby webapp: # Obraz, který se má použít pro tuto službu # Tento obraz je vzorová aplikace ASP.NET Core od Microsoftu image: mcr.microsoft.com/dotnet/core/samples:aspnetapp # Instrukce pro sestavení obrazu build: # Kontext pro sestavení, obvykle je to adresář obsahující Dockerfile context: . # Cesta k Dockerfile dockerfile: Dockerfile # Mapování portů mezi hostitelem a kontejnerem # Formát je \"host:kontejner\" # Toto nastavení říká Dockeru, aby přesměroval port 8000 na hostiteli na port 80 v kontejneru ports: - \"8000:80\" Zastavení Zastavit kontejner docker stop <docker container name or id> Odstranění Odstranění kontejneru docker rm <container name or id> Odstranění image docker rmi <docker image name or id> Dockerfile V dockeru není žádná výchozí složka. Tip Když vytváříte Dockerfile, můžete nastavit pracovní adresář v kontejneru pomocí příkazu WORKDIR. Tip Pokud není nastaven WORKDIR, vztahuje se vše na kořenový adresář (/) kontejneru. Příklady: Příklad pro .NET Core # Používáme oficiální .NET Core runtime image z Docker Hub # 'dotnet' je jméno image a '3.1' je tag, který specifikuje verzi FROM mcr.microsoft.com/dotnet/core/runtime:3.1 # Nastavíme pracovní adresář v kontejneru na /app # Pokud tento adresář neexistuje, docker ho vytvoří WORKDIR /app # Kopírujeme výstup buildu z našeho stroje do kontejneru # 'publish' je cesta k výstupu buildu na našem stroji # '.' znamená aktuální (pracovní) adresář v kontejneru COPY ./publish . # Nastavíme spustitelný soubor pro kontejner # 'myapp.dll' je název naší aplikace ENTRYPOINT [\"dotnet\", \"myapp.dll\"] Note Vytvoří docker image pro vaši aplikaci .NET Core. Když spustíte kontejner z této image, vaše aplikace se automaticky spustí. Příklad pro C# Aplikaci # Používáme oficiální .NET Core SDK image z Docker Hub # 'dotnet' je jméno image a '3.1' je tag, který specifikuje verzi FROM mcr.microsoft.com/dotnet/core/sdk:3.1 # Nastavíme pracovní adresář v kontejneru na /app # Pokud tento adresář neexistuje, docker ho vytvoří WORKDIR /app # Kopírujeme všechny soubory z našeho stroje do kontejneru # '.' znamená aktuální adresář na našem stroji # '.' znamená aktuální (pracovní) adresář v kontejneru COPY . . # Spustíme příkaz 'dotnet restore', který stáhne všechny potřebné NuGet balíčky RUN dotnet restore # Spustíme příkaz 'dotnet publish', který vytvoří výstup buildu naší aplikace RUN dotnet publish -c Release -o out # Nastavíme spustitelný soubor pro kontejner # 'myapp.dll' je název naší aplikace ENTRYPOINT [\"dotnet\", \"out/myapp.dll\"] Note Tento Dockerfile vytvoří docker image pro vaši aplikaci C#. Když spustíte kontejner z této image, vaše aplikace se automaticky spustí. Příklad .NET Core a lokálních NuGet balíčků # Používáme oficiální .NET Core SDK image z Docker Hub FROM mcr.microsoft.com/dotnet/core/sdk:3.1 # Nastavíme pracovní adresář v kontejneru na /app WORKDIR /app # Kopírujeme všechny soubory z našeho stroje do kontejneru COPY . . # Spustíme příkaz 'dotnet restore', který načte všechny potřebné NuGet balíčky z lokálního úložiště # Předpokládáme, že všechny potřebné NuGet balíčky jsou uloženy v adresáři 'nuget' našeho projektu RUN dotnet restore --source ./nuget # Spustíme příkaz 'dotnet publish', který vytvoří výstup buildu naší aplikace RUN dotnet publish -c Release -o out # Nastavíme spustitelný soubor pro kontejner ENTRYPOINT [\"dotnet\", \"out/myapp.dll\"] Tip V tomto příkladu předpokládáme, že všechny potřebné NuGet balíčky jsou uloženy v adresáři nuget vašeho projektu. Příkaz dotnet restore --source ./nuget pak načte tyto balíčky z lokálního úložiště místo stahování z internetu. Zachování dat z kontejneru na lokálním disku Volumes Propojení složky z Windows s kontejnerem v dockeru Nastavení Cesta Popis Host/Volume /run/desktop/mnt/host/c/Program Files/Unity/Hub/Editor/6000.0.33f1/Editor Cesta ke složce na hostitelském PC Path in container /app/unity Cesta uvnitř Docker kontejneru Note Host/Volume určuje cestu k existující složce na vašem počítači Path in container definuje, kde bude složka dostupná uvnitř kontejneru Řešení problémů Port není dostupný Pro řešení chyb jako \"Ports are not available\" nebo \"bind: An attempt was made to access a socket\" net stop winnat net start winnat Note Příkazy restartují službu Windows NAT (Network Address Translation), která spravuje síťovou komunikaci mezi hostitelským systémem a Docker kontejnery. Restart služby tak uvolní případné zablokované síťové porty."
  },
  "virtualization/docker_busybox.html": {
    "href": "virtualization/docker_busybox.html",
    "title": "| Vývojář",
    "summary": "Zjistěte, jaké máte docker volumes: docker volume ls Přenést data z docker volumes do počítače: docker run --rm -v projekty_planka_config:/volume -v C:\\Users\\xxx\\Docker_Volumes\\planka:/backup busybox:1.37.0-glibc sh -c \"cp -r /volume/. /backup/\" Note Základní parametry: --rm automaticky odstraní kontejner po dokončení operace šetří místo na disku a udržuje systém čistý Připojení volumes: -v projekty_planka_config:/volume připojí Docker volume projekty_planka_config v kontejneru bude dostupný jako adresář /volume slouží jako zdroj dat pro zálohu -v C:\\Users\\xxx\\Docker_Volumes\\planka:/backup připojí lokální složku z hostitelského systému v kontejneru bude dostupná jako /backup cílové umístění pro zálohu dat Použitý image a příkaz: busybox:1.37.0-glibc minimalistický Linux image obsahuje základní Unix nástroje verze s glibc pro lepší kompatibilitu sh -c \"cp -r /volume/. /backup/\" sh -c: spustí shell s následujícím příkazem cp -r: rekurzivní kopírování včetně podsložek /volume/.: kopíruje obsah složky volume /backup/: cílová složka pro zálohu"
  },
  "virtualization/docker_duplicati.html": {
    "href": "virtualization/docker_duplicati.html",
    "title": "| Vývojář",
    "summary": "Vytvoření a nastavení složky pro zálohy mkdir /cesta/k/tvojí/složce Přístup pro všechny: chmod 777 /cesta/k/tvojí/složce Tip Přístup pouze pro root. chmod 700 /cesta/k/tvojí/složce Nastavení oprávnění pro Docker volumes Pro zálohu je zapotřebí povolit přístup k souborům a ke složkám v dockeru. Povolit rekurzivně pro složky: find /docker_XX -type d -exec chmod 755 {} \\; Povolit rekurzivně pro soubory: find /docker_XX -type f -exec chmod 644 {} \\; Popis Cesta Host/volume /var/lib/docker/volumes (cesta k diskům) Path in container /docker_XX (vlastní cesta v kontejneru pro Volume) Important V kontejneru duplicati musí být nastaveno na \"Bind\". Tip Chcete-li vrátit zpět oprávnění na výchozí hodnoty, použijte následující příkaz: chown -R root:root/docker_XX Tento příkaz změní vlastníka a skupinu všech souborů a adresářů v /docker_XX na root, což je výchozí nastavení pro většinu systémů."
  },
  "virtualization/docker_portainer.html": {
    "href": "virtualization/docker_portainer.html",
    "title": "| Vývojář",
    "summary": "Spuštění docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.27.5 Note -d = Spustí kontejner na pozadí. -p 9000:9000 = Mapuje port 9000 na hostitelském stroji na port 9000 v kontejneru. --name portainer = Pojmenuje kontejner \"portainer\". --restart always = Kontejner se automaticky restartuje, pokud dojde k chybě nebo po restartu hostitelského stroje. -v /var/run/docker.sock:/var/run/docker.sock = Umožňuje portaineru komunikovat s docker daemonem. -v portainer_data:/data = Ukládá data portaineru do trvalého úložiště (Volume) portainer/portainer-ce:2.27.5 = Název docker image pro portainer."
  },
  "virtualization/kubernetes.html": {
    "href": "virtualization/kubernetes.html",
    "title": "| Vývojář",
    "summary": "Important Je zapotřebí znalost dockeru Orchestrátory Software nad kontejnerovou sítí, automaticky se stará o zavádění, údržbu a škálování kontejnerizovaných aplikací. V praxi umožňují efektivně využívat kapacitu serverů, reagují na podněty a dynamicky služby spouští, vypínají staré verze a zapínají nové apod. Note Dovedete si představit, jak obtížné je spravovat kontejnery, které mohou běžet i na stovkách serverů? > > Manuálně je to nad lidské síly, a proto se ke správě využívají orchestrátory. Je jedním z několika softwarových orchestrátorů. Ukázka orchestrátoru Note Orchestrátory usnadnily práci především vývojářům microservices. Microservices je architektura, kde aplikace je rozdělena na menší, nezávislé služby, které spolu komunikují prostřednictvím API."
  },
  "virtualization/wsl.html": {
    "href": "virtualization/wsl.html",
    "title": "| Vývojář",
    "summary": "WSL (Windows Subsystem for Linux) Wsl slouží k instalaci linuxových distribucí na Windows. Umožňuje spouštět linuxové aplikace přímo na Windows bez potřeby virtuálního stroje. Instalace Windows Important Pro správnou funkci WSL je nutné v BIOSu/UEFI povolit následující nastavení: Podpora CPU virtualizace U procesorů Intel: Intel VT-x U procesorů AMD: AMD-V nebo SVM (Secure Virtual Machine) Virtualizační technologie U procesorů Intel: VT-d (pokud je k dispozici) U procesorů AMD: AMD-Vi (pokud je k dispozici) Toto nastavení může být označeno jako \"Hardware Virtualization\" Vnořená virtualizace (Nested Virtualization) Toto nastavení je potřebné pouze v případě, že chcete používat virtualizaci uvnitř WSL, což není běžné pro všechny uživatele. V některých verzích BIOSu/UEFI je označeno jako \"VT-x/AMD-V Virtualization\". Kontrola povolení virtualizace: Stiskněte Ctrl + Shift + Esc Přejděte na záložku \"Performance\" (Výkon) Dole by mělo být \"Virtualization: Enabled\" Viz zde na obrázku: ] Povolení WSL na vašem počítači Ve výchozím nastavení je WSL na vašem PC deaktivovaný. (WSL = Windows Subsystem for Linux, umožňuje spouštět Linuxové distribuce na Windows.) Spustťte jako správce \"PowerShell\" Nyní povolíme WSL vložením následujícího příkazu: dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart Note Pokud vše proběhlo v pořádku, výstup bude vypadat takto: Povolení platformy Virtual Machine a WSL 2 na Windows Pro spuštění nejnovější verze WSL, což je WSL 2, musíte povolit \"Windows Virtual Machine Platform\". Použijte tento příkaz: dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart Note Výstup bude podobný tomuto: Important Aby se všechny nové změny a povolené funkce projevily, musíte restartovat počítač. Stažení aktualizace Linux jádra Nyní je čas stáhnout a nainstalovat aktualizační balíček linuxového jádra. Note Narazil jsem na problém, kdy WSL nefungoval správně s Dockerem, dokud jsem nenainstaloval poslední aktualizaci, která vše opravila. Proto doporučuji stáhnout a nainstalovat poslední aktualizaci jádra. Nastavení WSL 2 jako výchozí Nyní je čas nastavit nejnovější verzi WSL, tedy WSL 2, jako výchozí. Toho dosáhnete otevřením dalšího PowerShell terminálu jako správce (jak bylo ukázáno dříve) a spuštěním následujícího příkazu: wsl --set-default-version 2 Note Výstup bude vypadat takto: Instalace linuxové distribuce podle vašeho výběru pomocí WSL Nyní, když jsme plně připravili systém a nainstalovali všechny požadavky, můžeme konečně pokračovat s instalací linuxového subsystému na náš počítač. Stáhneme si libovolnou linuxovou distribuci podle našeho výběru \"RootFS\" (Root File System) a nainstalujeme ji pomocí WSL. Například pro Ubuntu wsl --import Ubuntu-22.04 C:\\WSL\\Ubuntu2204 C:\\UbuntuRootFS\\ubuntu-jammy-wsl-amd64-ubuntu22.04lts.rootfs.tar.gz --version 2 Note Ubuntu-22.04 = Název distribuce,který chcete použít. C:\\WSL\\Ubuntu2204 = Cesta, kde chcete mít nainstalovanou distribuci. C:\\UbuntuRootFS\\ubuntu-jammy-wsl-amd64-ubuntu22.04lts.rootfs.tar.gz = Cesta k souboru, který jste stáhli. --version 2 = Použití WSL 2 jako výchozí verze pro tuto distribuci. Nyní ověříme, zda je distribuce nainstalována správně pomocí příkazu: wsl --list Warning Pokud ste nainstalovali špatně distribuci, můžete ji odstranit pomocí příkazu: wsl --unregister <distro name> Například: wsl --unregister Ubuntu-22.04 To je vše, nyní máte nainstalovaný WSL na vašem počítači včetně linuxové distribuce. Pro detailní informace o instalaci WSL2 najdete kompletní návod na blogu Contabo."
  }
}